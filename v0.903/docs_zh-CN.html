<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YASP - Yet Another Sound Player (技术文档)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            padding-bottom: 50px; /* Add padding to prevent content from being hidden by the progress bar */
        }
        #progress-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 8px;
            background-color: #f0f0f0;
            z-index: 1000;
            cursor: pointer;
        }
        #progress-bar {
            height: 100%;
            width: 0;
            background-color: #0366d6;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h3 { font-size: 1.25em; }
        h4 { font-size: 1em; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        code {
            padding: .2em .4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 3px;
        }
        pre code {
            display: inline;
            padding: 0;
            margin: 0;
            overflow: visible;
            line-height: inherit;
            word-wrap: normal;
            background-color: transparent;
            border: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1em;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid #dfe2e5;
            padding: 6px 13px;
        }
        th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        ul, ol { padding-left: 2em; }
        li { margin-top: .25em; }

        /* Hierarchical TOC styles */
        .toc-level-1 { font-weight: 500; }
        .toc-level-2 { margin-left: 1.5em; }
        .toc-level-3 { margin-left: 3em; }
        .toc-level-4 { margin-left: 4.5em; }
        .toc-level-1 > a { font-size: 1.1em; }
        .toc-level-2 > a { font-size: 1.0em; }
        .toc-level-3 > a { font-size: 0.95em; }
        .toc-level-4 > a { font-size: 0.9em; color: #333; }

        blockquote {
            margin-left: 0;
            padding-left: 1em;
            color: #6a737d;
            border-left: .25em solid #dfe2e5;
        }
    </style>
</head>
<body>
<div id="progress-container">
    <div id="progress-bar"></div>
</div>
<h1 id="yasp-yet-another-sound-player">YASP - Yet Another Sound Player (技术文档)</h1>
<h2 id="">摘要</h2>
<p>YASP (Yet Another Sound Player) 是一款专为 SPFM (Sound-Processing FM-synthesis) 系列硬件设计的、功能强大的命令行音乐播放器。它专注于高效、精确地播放经典的 VGM 和 S98 格式音乐文件。本文档旨在深入剖析其核心技术实现，包括高级计时系统、SPFM 通信协议、以及创新的芯片转换与缓存机制。</p>
<hr>
<h2 id="table-of-contents">目录</h2>
<ul>
<li class="toc-level-1"><a href="#1">1. 源码参考与致谢</a></li>
<li class="toc-level-1"><a href="#2">2. 项目背景与架构</a></li>
<li class="toc-level-1"><a href="#3">3. 核心功能与特色</a></li>
<li class="toc-level-1"><a href="#4">4. 关键技术剖析</a></li>
<li class="toc-level-2"><a href="#4-1">4.1. VGM 文件处理流程</a></li>
<li class="toc-level-2"><a href="#4-2">4.2. 智能芯片转换</a></li>
<li class="toc-level-3"><a href="#4-2-1">4.2.1. 转换路径概览</a></li>
<li class="toc-level-3"><a href="#4-2-2">4.2.2. OPN 到 OPM 的详细转换规则</a></li>
<li class="toc-level-3"><a href="#4-2-3">4.2.3. AY-8910 到 OPM 的详细转换规则</a></li>
<li class="toc-level-2"><a href="#4-3">4.3. 高级计时与刷新系统</a></li>
<li class="toc-level-3"><a href="#4-3-1">4.3.1. 刷新模式 (Flush Mode)</a></li>
<li class="toc-level-3"><a href="#4-3-2">4.3.2. 定时器模式 (Timer Mode)</a></li>
<li class="toc-level-3"><a href="#4-3-3">4.3.3. 定时器核心源码详解</a></li>
<li class="toc-level-2"><a href="#4-4">4.4. SPFM 通信协议</a></li>
<li class="toc-level-1"><a href="#5">5. 性能优化-版本对比</a></li>
<li class="toc-level-2"><a href="#5-1">5.1. 问题根源：为什么旧版本更快？</a></li>
<li class="toc-level-2"><a href="#5-2">5.2. 修复措施：如何恢复并超越旧版性能</a></li>
<li class="toc-level-1"><a href="#6">6. 操作指南</a></li>
<li class="toc-level-1"><a href="#7">7. 编译与构建</a></li>
<li class="toc-level-1"><a href="#8">8. 故障排查与更新日志</a></li>
<li class="toc-level-2"><a href="#8-1">8.1. 故障排查：播放时不受控制地快速切换曲目</a></li>
<li class="toc-level-3"><a href="#8-1-1">8.1.1. 诊断过程</a></li>
<li class="toc-level-3"><a href="#8-1-2">8.1.2. 最终解决方案</a></li>
<li class="toc-level-2"><a href="#8-2">8.2. Bug 修复与改进日志 (v0.881)</a></li>
<li class="toc-level-3"><a href="#8-2-1">8.2.1. 修复了转换后 VGM 文件的循环逻辑</a></li>
<li class="toc-level-3"><a href="#8-2-2">8.2.2. 修复了播放完成后的自动切歌问题</a></li>
<li class="toc-level-3"><a href="#8-2-3">8.2.3. 修正了 UI 中总时间的计算</a></li>
<li class="toc-level-3"><a href="#8-2-4">8.2.4. 修正了 UI 中 VGM 芯片信息的显示</a></li>
<li class="toc-level-3"><a href="#8-2-5">8.2.5. 增加了对无效 VGM 文件的检测</a></li>
<li class="toc-level-2"><a href="#8-3">8.3. 功能改进与错误修复 (v0.884)</a></li>
<li class="toc-level-3"><a href="#8-3-1">8.3.1. 启动流程与目录管理优化</a></li>
<li class="toc-level-3"><a href="#8-3-2">8.3.2. 文件浏览器功能增强</a></li>
<li class="toc-level-3"><a href="#8-3-3">8.3.3. 增加清理缓存功能</a></li>
<li class="toc-level-2"><a href="#8-4">8.4. AY-8910 包络波形转换修复 (v0.888)</a></li>
<li class="toc-level-2"><a href="#8-5">8.5. AY-8910 快速琶音转换修复 (v0.903)</a></li>
</ul>
<hr>
<h2 id="1">1. 源码参考与致谢</h2>
<p><a id="1"></a></p>
<p>YASP 的开发深度参考了以下优秀项目，在此对这些项目的作者表示由衷的敬意和感谢。他们的工作为 YASP 的实现提供了坚实的基础和关键的灵感。</p>
<ul>
<li>  <strong><code>yasp (Yet Another SPFM Light Player)</code></strong></li>
<li>  <strong>作者</strong>: uobikiemukot</li>
<li>  <strong>贡献</strong>: <strong>本项目的起点和最初的灵感来源。</strong> YASP 的名称继承自此项目，其早期的代码结构为本项目的开发提供了宝贵的初始框架和方向。</li>
</ul>
<ul>
<li>  <strong><code>node-spfm</code></strong></li>
<li>  <strong>作者</strong>: Mitsutaka Okazaki (digital-sound-antiques), Denjhang</li>
<li>  <strong>贡献</strong>: 提供了本项目的核心逻辑和算法基础，特别是在 SPFM 通信协议 (<code>spfm.c</code>)、芯片控制以及 OPN 到 OPM 的转换算法 (<code>opn_to_opm.c</code>) 方面。</li>
</ul>
<ul>
<li>  <strong><code>VGMPlay</code></strong></li>
<li>  <strong>作者</strong>: Valley Bell</li>
<li>  <strong>贡献</strong>: 本项目的高级计时系统 (<code>util.c</code> 中的 <code>yasp_usleep</code>) 完全基于 VGMPlay 的核心计时模型，从根本上解决了播放稳定性的问题。模式 6 (VGMPlay Mode) 和模式 7 (Optimized VGMPlay Mode) 直接来源于其思想。</li>
</ul>
<ul>
<li>  <strong><code>vgmplay-msx</code></strong></li>
<li>  <strong>作者</strong>: Laurens Holst (grauw)</li>
<li>  <strong>贡献</strong>: 为 OPN 到 OPM 的 LFO 频率转换提供了精确的查找表，源自其项目中的 <code>vgmplay-msx/src/drivers/emulations/OPNFMOnSFG.asm</code> 文件。没有这个参考，就不可能实现听感上正确的 LFO 效果。</li>
</ul>
<ul>
<li>  <strong><code>vgm-conv</code></strong></li>
<li>  <strong>作者</strong>: Mitsutaka Okazaki (digital-sound-antiques)</li>
<li>  <strong>贡献</strong>: 芯片频率转换的精确数学模型来源于此项目。</li>
</ul>
<ul>
<li>  <strong><code>vgm-parser-js</code></strong></li>
<li>  <strong>作者</strong>: Mitsutaka Okazaki (digital-sound-antiques)</li>
<li>  <strong>贡献</strong>: 在解决 GD3 标签缓存问题时，本项目借鉴了其 <code>vgm-parser-main</code> 模块中健壮的“完整文件载入内存”处理策略 (<code>vgm.c</code>)，为最终的成功实现提供了关键思路。</li>
</ul>
<ul>
<li>  <strong><code>Vortex Tracker II</code></strong></li>
<li>  <strong>作者</strong>: Sergey Bulba (salah)</li>
<li>  <strong>贡献</strong>: 为本项目在实现 AY-8910 高级编程技巧（如“包络波形转换”）方面提供了重要的灵感和参考。</li>
</ul>
<h2 id="2">2. 项目背景与架构</h2>
<p><a id="2"></a></p>
<p>YASP 旨在为 SPFM 硬件爱好者提供一个功能强大且高度可定制的命令行音乐播放器。项目由 <strong>Denjhang</strong> (项目所有者/主要开发者) 和 <strong>Cline</strong> (AI 软件工程师) 合作完成，前者负责需求、架构和关键技术验证，后者负责具体实现、集成和文档撰写。</p>
<p><strong>核心架构:</strong></p>
<ul>
<li>  <code>main.c</code>: 主程序入口，负责初始化、配置加载、主播放循环和键盘输入处理。</li>
<li>  <code>play.c</code>: 播放器 UI 渲染和状态管理的核心。</li>
<li>  <code>vgm.c</code> / <code>s98.c</code>: 分别负责 VGM 和 S98 文件的解析、命令处理和播放逻辑。</li>
<li>  <code>opn_to_opm.c</code>, <code>ay_to_opm.c</code>, <code>sn_to_ay.c</code>: 实现芯片指令转换的模块。</li>
<li>  <code>util.c</code>: 包含高精度定时器、<code>yasp_usleep</code> 实现和 <code>ini</code> 文件读写等辅助工具。</li>
<li>  <code>spfm.c</code>: 封装了与 SPFM 硬件通过 FTDI D2XX 驱动进行通信的底层逻辑。</li>
</ul>
<h2 id="3">3. 核心功能与特色</h2>
<p><a id="3"></a></p>
<ul>
<li>  <strong>广泛的芯片支持:</strong> YASP 支持多种经典的音源芯片，无论是直接播放还是通过自动转换，覆盖了大量怀旧游戏音乐的需求。支持的芯片列表如下：</li>
<li>  YM2608, YM2151, YM2612, YM2203, YM2413, YM3526, YM3812, Y8950, AY8910, SN76489, YMF262, SEGAPCM, RF5C68, YM2610</li>
<li>  <strong>多格式播放:</strong> 支持 <code>.vgm</code>, <code>.vgz</code>, 和 <code>.s98</code> 音乐文件。</li>
<li>  <strong>GD3 标签保真:</strong> 采用先进的内存处理技术，确保在转换和缓存过程中，VGM 文件内的 GD3 音乐标签被完整保留。</li>
<li>  <strong>高级计时系统:</strong> 提供多种基于高精度性能计数器的计时策略，确保在各种系统负载下都能实现精确、无抖动的音频播放。</li>
<li>  <strong>内置文件浏览器:</strong> 方便用户在文件系统中导航和选择音乐。</li>
</ul>
<h2 id="4">4. 关键技术剖析</h2>
<p><a id="4"></a></p>
<h3 id="4-1">4.1. VGM 文件处理流程</h3>
<p><a id="4-1"></a></p>
<p>为了解决在文件转换和缓存过程中遇到的数据一致性问题（特别是 GD3 标签的丢失），YASP 采用了一种健壮的、基于内存的处理流程。该机制的核心是：在需要创建缓存时，<strong>先将整个原始 VGM 文件一次性完整读入内存</strong>，然后关闭文件句柄。后续的转换、GD3 标签提取和新缓存文件的写入，都基于这个内存副本进行操作。这种“先完整载入，再隔离处理”的策略，确保了数据源的唯一性和不可变性，是保证播放流畅、转换无误和 GD3 标签不丢失的基石。</p>
<p>以下是 <code>vgm.c</code> 中 <code>vgm_play</code> 函数实现此流程的关键代码：</p>
<p><strong>1. 将整个原始 VGM 文件读入内存</strong></p>
<pre><code class="language-c">// 1. Read entire original file into memory
fseek(input_fp, 0, SEEK_END);
long original_file_size = ftell(input_fp);
fseek(input_fp, 0, SEEK_SET);
uint8_t* original_file_data = malloc(original_file_size);
if (!original_file_data || fread(original_file_data, 1, original_file_size, input_fp) != original_file_size) {
    logging(LOG_ERROR, &quot;Failed to read original VGM file into memory.&quot;);
    if (original_file_data) free(original_file_data);
    return;
}
fclose(input_fp); // Close original file, we have it in memory now
</code></pre>
<p><strong>解说</strong>: 这是“先完整载入”策略的直接体现。代码获取文件大小，分配等大的内存，然后一次性将整个文件读入 <code>original_file_data</code> 缓冲区。完成后，立即关闭原始文件句柄，后续所有操作都与磁盘上的原始文件无关，从根本上避免了文件指针混乱的问题。</p>
<p><strong>2. 从内存中提取 GD3 标签并写入缓存</strong></p>
<pre><code class="language-c">// 4. Write GD3 block from memory to cache
long gd3_start_in_cache = 0;
uint32_t gd3_offset_in_header = read_le32(original_file_data + 0x14);
if (gd3_offset_in_header &gt; 0) {
    uint32_t gd3_abs_offset = 0x14 + gd3_offset_in_header;
    uint32_t gd3_length = read_le32(original_file_data + gd3_abs_offset + 8);
    uint32_t total_gd3_size = 12 + gd3_length;
    
    gd3_start_in_cache = ftell(g_cache_fp);
    fwrite(original_file_data + gd3_abs_offset, 1, total_gd3_size, g_cache_fp);
}
</code></pre>
<p><strong>解说</strong>: 这是“隔离处理”策略的关键一步。代码直接从内存缓冲区 <code>original_file_data</code> 中读取 GD3 标签的偏移和长度，然后将完整的 GD3 数据块（包括头部和内容）原封不动地写入新的缓存文件。这确保了 GD3 信息的无损迁移。</p>
<p><strong>3. 从内存中进行数据转换</strong></p>
<pre><code class="language-c">// In vgm_play:
const uint8_t* vgm_data_ptr = original_file_data + g_vgm_header.vgm_data_offset;
size_t vgm_data_size = (g_vgm_header.eof_offset + 4) - g_vgm_header.vgm_data_offset;
vgm_convert_and_cache_opn_to_opm_from_mem(vgm_data_ptr, vgm_data_size, &amp;g_vgm_header);

// The conversion function itself:
static bool vgm_convert_and_cache_opn_to_opm_from_mem(const uint8_t* vgm_data, size_t vgm_data_size, const vgm_header_t* original_header) {
    // ... loop through vgm_data (memory buffer) and convert ...
}
</code></pre>
<p><strong>解说</strong>: 转换函数 <code>vgm_convert_and_cache_opn_to_opm_from_mem</code> 的输入不再是文件指针，而是指向内存中 VGM 数据部分的指针 <code>vgm_data</code>。这彻底避免了在文件流上进行读写操作可能引发的数据不一致问题，保证了转换过程的纯粹和可靠。</p>
<h3 id="4-2">4.2. 智能芯片转换</h3>
<p><a id="4-2"></a></p>
<p>当检测到用户硬件上缺少 VGM 文件所需的芯片，但存在可替代的目标芯片时，YASP 会自动执行转换。</p>
<h4 id="4-2-1">4.2.1. 转换路径概览</h4>
<p><a id="4-2-1"></a></p>
<table>
<thead>
<tr>
<th>源芯片 (Source)</th>
<th>目标芯片 (Target)</th>
<th>转换模块</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>YM2612/2203/2608 (OPN)</strong></td>
<td>YM2151 (OPM)</td>
<td><code>opn_to_opm.c</code></td>
<td>核心 FM 音源转换，支持频率、包络等参数映射。</td>
</tr>
<tr>
<td><strong>AY8910 (PSG)</strong></td>
<td>YM2151 (OPM)</td>
<td><code>ay_to_opm.c</code></td>
<td>使用 OPM 的 FM 合成来模拟 PSG 的方波和噪声。</td>
</tr>
<tr>
<td><strong>SN76489 (DCSG)</strong></td>
<td>AY8910 (PSG)</td>
<td><code>sn_to_ay.c</code></td>
<td>中间步骤，将 SN76489 指令转为 AY8910 指令。</td>
</tr>
<tr>
<td><strong>SN76489 (DCSG)</strong></td>
<td>YM2151 (OPM)</td>
<td><code>sn_to_ay.c</code> -> <code>ay_to_opm.c</code></td>
<td><strong>转换链</strong>：SN76489 -> AY8910 -> YM2151。</td>
</tr>
</tbody>
</table>
<h4 id="4-2-2">4.2.2. OPN 到 OPM 的详细转换规则</h4>
<p><a id="4-2-2"></a></p>
<p>为了在没有 OPN 芯片的情况下播放 OPN 音乐，YASP 实现了一个实时的寄存器级转换器。它将 OPN 的寄存器写入转换为功能上等效的 OPM 寄存器写入。</p>
<h5 id="4-2-2-1">4.2.2.1. 寄存器映射总览</h5>
<table>
<thead>
<tr>
<th>OPN (YM2612/2203)</th>
<th>OPM (YM2151)</th>
<th>简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x22</code> (LFRQ)</td>
<td><code>0x18</code> (LFRQ)</td>
<td>LFO 频率转换</td>
</tr>
<tr>
<td><code>0x28</code> (Key On/Off)</td>
<td><code>0x08</code> (Key On/Off)</td>
<td>通道与操作员的开关</td>
</tr>
<tr>
<td><code>0x30..0x8F</code> (Operator)</td>
<td><code>0x40..0xBF</code> (Operator)</td>
<td>操作员参数（DT, MUL, TL, KS, AR, DR, SR, RR, SL, SSG-EG）</td>
</tr>
<tr>
<td><code>0xA0..0xA6</code> (F-Num/Block)</td>
<td><code>0x28..0x37</code> (KC/KF)</td>
<td>频率（音高）转换</td>
</tr>
<tr>
<td><code>0xB0..0xB2</code> (FB/CONNECT)</td>
<td><code>0x20..0x27</code> (RL/FB/CONNECT)</td>
<td>反馈与算法</td>
</tr>
<tr>
<td><code>B4..B6</code> (L/R/AMS/PMS)</td>
<td><code>0x38..0x3F</code> (PMS/AMS)</td>
<td>声道、LFO 灵敏度</td>
</tr>
</tbody>
</table>
<h5 id="4-2-2-2">4.2.2.2. 详细转换规则</h5>
<h6 id="1">1. LFO 频率 (LFRQ)</h6>
<ul>
<li>  <strong>OPN <code>0x22</code> -> OPM <code>0x18</code></strong></li>
<li>  OPN 的 LFO 频率只有 8 级，而 OPM 更加精细。转换器使用一个查找表（LUT）来映射 OPN 的值到 OPM 上一个最接近的等效值。这个 LUT 基于 <code>OPNFMOnSFG.asm</code> 的实现，以确保听感上的一致性。</li>
</ul>
<p>    <strong>查找表 (C 语言数组):</strong></p>
<pre><code class="language- ```c">    const uint8_t lfo_lut[] = {0, 0, 0, 0, 0, 0, 0, 0, 0xC1, 0xC7, 0xC9, 0xCB, 0xCD, 0xD4, 0xF9, 0xFF};
</code></pre>
<p>    <strong>用法示例:</strong></p>
<p>    当 OPN 的 <code>0x22</code> 寄存器接收到一个值时，程序会取其低 4 位 (<code>data & 0x0F</code>) 作为索引，在 <code>lfo_lut</code> 数组中查找对应的 OPM 值，并将其写入 OPM 的 <code>0x18</code> 寄存器。</p>
<table>
<thead>
<tr>
<th>OPN <code>0x22</code> 输入值 (data)</th>
<th>索引 (data & 0x0F)</th>
<th>OPM <code>0x18</code> 输出值 (lfo_lut[index])</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0x00</code> - <code>0x07</code></td>
<td>0 - 7</td>
<td><code>0x00</code> (LFO 关闭)</td>
</tr>
<tr>
<td><code>0x08</code></td>
<td>8</td>
<td><code>0xC1</code></td>
</tr>
<tr>
<td><code>0x09</code></td>
<td>9</td>
<td><code>0xC7</code></td>
</tr>
<tr>
<td><code>0x0A</code></td>
<td>10</td>
<td><code>0xC9</code></td>
</tr>
<tr>
<td><code>0x0B</code></td>
<td>11</td>
<td><code>0xCB</code></td>
</tr>
<tr>
<td><code>0x0C</code></td>
<td>12</td>
<td><code>0xCD</code></td>
</tr>
<tr>
<td><code>0x0D</code></td>
<td>13</td>
<td><code>0xD4</code></td>
</tr>
<tr>
<td><code>0x0E</code></td>
<td>14</td>
<td><code>0xF9</code></td>
</tr>
<tr>
<td><code>0x0F</code></td>
<td>15</td>
<td><code>0xFF</code></td>
</tr>
</tbody>
</table>
<h6 id="2">2. Key On/Off</h6>
<ul>
<li>  <strong>OPN <code>0x28</code> -> OPM <code>0x08</code></strong></li>
<li>  这个寄存器控制哪个通道的哪些操作员（Slot）发声或停止。OPN 的通道选择在低 3 位，而 OPM 在低 3 位。OPN 的操作员选择在高 4 位，而 OPM 在高 3 位。转换时需要进行相应的位移和屏蔽。</li>
</ul>
<ul>
<li>  <strong>关键代码</strong>: <code>_write_func(0x08, (slots << 3) | ch);</code></li>
</ul>
<h6 id="3">3. 操作员参数 (DT, MUL, TL, etc.)</h6>
<ul>
<li>  <strong>OPN <code>0x30..0x8F</code> -> OPM <code>0x40..0xBF</code></strong></li>
<li>  这些寄存器控制了 FM 合成的核心参数，如Detune, Multiple, Total Level, Attack Rate等。幸运的是，OPN 和 OPM 在这些参数的位定义上大部分是兼容的。转换主要是地址的重新计算。</li>
<li>  OPN 的地址格式为 <code>Base + Channel + SlotOffset</code>，而 OPM 是 <code>Base + Channel + SlotOffset</code>。转换函数需要根据输入的 OPN 地址计算出对应的 OPM 地址。</li>
<li>  <strong>关键代码</strong>: <code>uint8_t base = 0x40 + ((addr & 0xf0) - 0x30) <em> 2; uint8_t offset = slot </em> 8 + ch; _write_func(base + offset, data);</code></li>
</ul>
<h6 id="4">4. 频率 (F-Number/Block 到 Key Code/Fraction)</h6>
<ul>
<li>  <strong>OPN <code>0xA0..0xA6</code> -> OPM <code>0x28..0x37</code></strong></li>
<li>  这是最复杂的转换。OPN 使用 <code>F-Number</code> 和 <code>Block</code>（八度）来定义频率，而 OPM 使用 <code>Key Code</code> (音符) 和 <code>Key Fraction</code> (精细调谐)。</li>
<li>  转换过程如下：</li>
</ul>
<ol>
<li> 根据 OPN 的 F-Num 和 Block 计算出实际的频率值 (Hz)。</li>
<li> <code>freq = (source_clock <em> fnum) / (divisor </em> (1 << (20 - blk)))</code></li>
<li> 将计算出的频率 (Hz) 再转换为 OPM 的音符和音分。</li>
<li> <code>key = 60 + log2((freq <em> clock_ratio) / BASE_FREQ_OPM) </em> 12.0</code></li>
<li> 最后将 <code>key</code> 分解为 OPM 的 <code>KC</code> (八度+音符) 和 <code>KF</code> (音分) 并写入相应寄存器。</li>
</ol>
<ul>
<li>  <strong>关键代码</strong>: <code>opn_freq_to_opm_key(fnum, blk, &kc, &kf); _write_func(0x28 + ch, kc); _write_func(0x30 + ch, kf << 2);</code></li>
</ul>
<h6 id="5">5. 反馈/算法 (FB/CONNECT)</h6>
<ul>
<li>  <strong>OPN <code>0xB0..0xB2</code> -> OPM <code>0x20..0x27</code></strong></li>
<li>  OPN 和 OPM 在此处的位定义相似，但 OPM 的寄存器还包含了声道信息（RL）。因此，在写入时，需要先从缓存中读取该通道的声道设置，然后与反馈/算法值合并后再写入。</li>
</ul>
<ul>
<li>  <strong>关键代码</strong>: <code>_write_func(0x20 + ch, (get_rl_flags(ch) << 6) | (data & 0x3f));</code></li>
</ul>
<h6 id="6">6. 声道/LFO 灵敏度 (L/R/AMS/PMS)</h6>
<ul>
<li>  <strong>OPN <code>0xB4..0xB6</code> -> OPM <code>0x38..0x3F</code></strong></li>
<li>  OPN 将声道（L/R）和 LFO 灵敏度（AMS/PMS）打包在同一个寄存器中，而 OPM 将它们分开。</li>
<li>  转换时：</li>
</ul>
<ol>
<li> 从 OPN 寄存器中提取出声道信息并缓存起来（供其他寄存器转换时使用）。</li>
<li> 提取 PMS（音高调制灵敏度）和 AMS（幅度调制灵敏度）。</li>
<li> 特别地，为了让用户可以实时控制 LFO 效果的强度，代码中会对 PMS 值应用一个全局的幅度乘数 <code>g_opn_lfo_amplitude</code>。经过反复测试，当此缩放参数设置为 <strong>0.9</strong> 时，转换后的音效最接近原始 OPN 的听感。</li>
<li> 将处理后的 PMS 和 AMS 写入 OPM 的 <code>0x38-0x3F</code> 寄存器。</li>
</ol>
<ul>
<li>  <strong>关键代码</strong>: <code>uint8_t scaled_pms = (uint8_t)(pms * g_opn_lfo_amplitude); _write_func(0x38 + ch, (scaled_pms << 4) | ams);</code></li>
</ul>
<h4 id="4-2-3">4.2.3. AY-8910 到 OPM 的详细转换规则</h4>
<p><a id="4-2-3"></a></p>
<p>将 AY-8910 (PSG) 的声音转换为 YM2151 (OPM) 是一项独特的挑战，因为它需要用 FM 合成来<strong>模拟</strong>一个完全不同的声音生成方式（可编程声音发生器）。YASP 使用 OPM 的 3 个通道来模拟 PSG 的 3 个方波通道，并使用第 4 个通道来模拟其噪声。</p>
<h5 id="4-2-3-1">4.2.3.1. 寄存器映射总览</h5>
<table>
<thead>
<tr>
<th>AY-8910 (PSG)</th>
<th>YM2151 (OPM)</th>
<th>简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>R0, R1</code> (音调周期 A)</td>
<td><code>0x28, 0x30</code> (KC/KF Ch 4)</td>
<td>通道 A 的频率</td>
</tr>
<tr>
<td><code>R2, R3</code> (音调周期 B)</td>
<td><code>0x29, 0x31</code> (KC/KF Ch 5)</td>
<td>通道 B 的频率</td>
</tr>
<tr>
<td><code>R4, R5</code> (音调周期 C)</td>
<td><code>0x2A, 0x32</code> (KC/KF Ch 6)</td>
<td>通道 C 的频率</td>
</tr>
<tr>
<td><code>R6</code> (噪声周期)</td>
<td><code>0x0F</code> (Noise Control)</td>
<td>噪声频率</td>
</tr>
<tr>
<td><code>R7</code> (混音器)</td>
<td><code>0x70-0x77</code> (TL) / <code>0x08</code> (Key On/Off)</td>
<td>控制方波/噪声的开关和音量</td>
</tr>
<tr>
<td><code>R8</code> (音量 A)</td>
<td><code>0x74</code> (TL Ch 4)</td>
<td>通道 A 的音量</td>
</tr>
<tr>
<td><code>R9</code> (音量 B)</td>
<td><code>0x75</code> (TL Ch 5)</td>
<td>通道 B 的音量</td>
</tr>
<tr>
<td><code>R10</code> (音量 C)</td>
<td><code>0x76</code> (TL Ch 6)</td>
<td>通道 C 的音量</td>
</tr>
<tr>
<td><code>R11, R12</code> (包络周期)</td>
<td>(内部状态)</td>
<td>包络发生器的频率</td>
</tr>
<tr>
<td><code>R13</code> (包络形状)</td>
<td>(内部状态) / <code>0x28, 0x30</code> (KC/KF)</td>
<td>包络形状，或作为波形发生器时的音高</td>
</tr>
</tbody>
</table>
<h5 id="4-2-3-2">4.2.3.2. 详细转换规则</h5>
<h6 id="1">1. 方波音调 (Tone)</h6>
<ul>
<li>  <strong>AY <code>R0-R5</code> -> OPM <code>0x28-0x32</code></strong></li>
<li>  AY-8910 使用一个 12-bit 的周期值来定义方波的频率。转换器首先根据这个周期值计算出实际的频率 (Hz)。</li>
<li>  <strong>频率计算</strong>: <code>freq = source_clock / (16 * tone_period)</code></li>
<li>  然后，这个频率值被送入与 OPN->OPM 转换相同的 <code>freqToOPMNote</code> 函数，计算出 OPM 的 <code>KC</code> (音符) 和 <code>KF</code> (音分) 值，并写入 OPM 对应通道的频率寄存器。</li>
<li>  为了模拟方波的音色，OPM 通道被预设为一个简单的 FM 配置，产生接近方波的谐波。以下是该音色在 MML2VGM 中的定义格式：</li>
</ul>
<pre><code class="language- ```">    &apos;@ PSG Square Wave
       AR  DR  SR  RR  SL  TL  KS  ML  DT1 DT2 AME
    &apos;@ 031,000,000,000,000,027,000,002,000,000,000 ; M1 (调制器)
    &apos;@ 031,000,000,000,000,000,000,001,000,000,000 ; C1 (载波)
    &apos;@ 000,000,000,000,000,000,000,000,000,000,000 ; M2 (未使用)
    &apos;@ 000,000,000,000,000,000,000,000,000,000,000 ; C2 (未使用)
       ALG FB
    &apos;@ 004,007
</code></pre>
<p>    <strong>解说</strong>:</p>
<ul>
<li>  使用<strong>算法4</strong>，其中一个调制器（M1）作用于一个载波（C1）。</li>
<li>  <strong>反馈（FB）设为7</strong>，给调制器自身增加谐波，使其音色更接近方波。</li>
<li>  调制器的<strong>倍频（ML）为2</strong>，载波的<strong>倍频为1</strong>，这种非整数倍关系有助于产生丰富的奇次谐波。</li>
<li>  调制器的<strong>电平（TL）设为27</strong>，这是一个固定的、经过听感优化的值，用于控制谐波的强度。载波的电平在音色定义中为0（最大音量），实际播放时由 PSG 的音量寄存器动态控制。</li>
</ul>
<h6 id="2">2. 噪声 (Noise)</h6>
<ul>
<li>  <strong>AY <code>R6</code> -> OPM <code>0x0F</code></strong></li>
<li>  AY-8910 的噪声周期（5-bit）被直接映射到 OPM 的噪声控制寄存器。OPM 的噪声频率是反向的（值越小频率越高），因此需要进行一次反转。</li>
</ul>
<ul>
<li>  <strong>关键代码</strong>: <code>_y(0x0f, 0x80 | (0x1f - nfreq));</code></li>
<li>  噪声的音量则取三个 PSG 通道中，凡是开启了噪声开关的通道里，音量最大的那个。</li>
</ul>
<h6 id="3">3. 音量与混音器 (Volume & Mixer)</h6>
<ul>
<li>  <strong>AY <code>R7-R10</code> -> OPM <code>0x70-0x77</code></strong></li>
<li>  这是转换逻辑的核心部分。AY-8910 的 <code>R7</code> 混音器寄存器决定了每个通道是输出方波、噪声，还是两者都输出，或是静音。</li>
<li>  转换器通过 <code>_updateTone</code> 函数来处理这个逻辑。对于每个通道，它会检查 <code>R7</code> 中对应的方波开关和噪声开关。</li>
<li>  如果方波开关打开，则根据 <code>R8-R10</code> 中设定的音量（4-bit），通过一个查找表 <code>VOL_TO_TL</code> 转换为 OPM 的总电平（Total Level, 7-bit）值，并写入 OPM 对应通道的音量寄存器。</li>
<li>  如果方波开关关闭，则将 OPM 通道静音（TL 设为 127）。</li>
</ul>
<h6 id="4">4. 独家功能：包络波形转换 (Envelope as Waveform)</h6>
<ul>
<li>  <strong>AY <code>R11-R13</code> -> OPM <code>0x28-0x32</code> (频率) & <code>0x70-0x77</code> (音量)</strong></li>
<li>  这是 YASP 的一项独家功能，解决了 chiptune 音乐中的一个常见高级技巧。在 AY-8910 上，可以通过设置一个极短的包络周期，让硬件包络本身高速振荡，从而<strong>作为一种新的音源</strong>来使用。</li>
<li>  <strong>检测机制</strong>: 转换器通过检查包络周期寄存器 (<code>R11</code>, <code>R12</code>) 的值来判断是否启用了此模式。如果周期值非常小（在代码中阈值设为 <code>200</code>），则认为包络正在被用作波形发生器。</li>
</ul>
<pre><code class="language- ```c">    // ay_to_opm.c
    const int envelope_as_waveform = (v &amp; 0x10) &amp;&amp; (_envelope_period &lt; 200);
</code></pre>
<ul>
<li>  <strong>频率计算</strong>: 当此模式被激活时，通道的音高不再由其方波周期寄存器决定，而是由<strong>包络的频率</strong>决定。转换器会根据包络的形状（决定了波形的步数，如锯齿波32步，三角波64步）和包络周期，计算出其实际音高。</li>
</ul>
<pre><code class="language- ```c">    // ay_to_opm.c
    int steps = 0;
    switch (_envelope_shape) {
        case 8: case 11: case 12: case 13: steps = 32; break; // Sawtooth
        case 10: case 14: steps = 64; break; // Triangle
        // ...
    }
    const double freq = (double)_source_clock / (16.0 * _envelope_period * steps);
    _updateFreq(ch, freq); // 使用这个新频率更新 OPM 通道
</code></pre>
<ul>
<li>  <strong>音量与混音器修正</strong>: 这是整个功能得以实现的最关键一步。当一个通道使用包络作为波形时，作曲者通常会<strong>关闭该通道的方波开关</strong>（在 <code>R7</code> 中）。旧的逻辑会将此错误地判断为“静音”。新的 <code>_updateTone</code> 函数修正了这一点：</li>
</ul>
<pre><code class="language- ```c">    // ay_to_opm.c
    const int tone_enabled = ((1 &lt;&lt; ch) &amp; _regs[7]) == 0;
    const int envelope_as_waveform = (v &amp; 0x10) &amp;&amp; (_envelope_period &lt; 200);

    if (tone_enabled || envelope_as_waveform) {
        // 只要方波开启 或 包络在当波形用，就设置音量
        tVol = 15; // 当作波形时，音量最大
        _y(0x70 + opmCh, fmin(127, VOL_TO_TL[tVol &amp; 0xf]));
    } else {
        // 否则才静音
        _y(0x70 + opmCh, 0x7f);
    }
</code></pre>
<p>这个 <code>if (tone_enabled || envelope_as_waveform)</code> 的判断，确保了即使方波开关关闭，只要通道在使用包络波形，它依然能被正确地发声，从而完美再现了原始 chiptune 的效果。</p>
<h6 id="5">5. 独家功能：ZX-Spectrum 风格的立体声声像 (Stereo Panning)</h6>
<ul>
<li>  <strong>背景</strong>: 原始的 AY-8910 芯片是单声道的。然而，在 ZX-Spectrum 社区，开发者们通过使用两颗 AY-8910 芯片（或其变体）创造出了多种“伪立体声”配置，最经典的就是 <strong>ABC</strong> 配置（通道 A 在左，B 居中，C 在右）。YASP 在 AY-8910 到 OPM 的转换中，不仅支持了这种经典配置，还扩展了多种模式，让用户可以实时切换，体验不同的立体声效果。</li>
<li>  <strong>实现机制</strong>:</li>
</ul>
<ol>
<li> <strong>定义声像常量</strong>: 在 OPM (YM2151) 中，声像由寄存器 <code>0x20-0x27</code> 的最高两位（<code>RL</code>）控制。代码中定义了三个常量来表示左、右和中央声道：</li>
</ol>
<pre><code class="language-     ```c">        #define OPM_PAN_LEFT   0x40 // C2 (二进制 01xxxxxx)
        #define OPM_PAN_RIGHT  0x80 // C1 (二进制 10xxxxxx)
        #define OPM_PAN_CENTER 0xC0 // C1 &amp; C2 (二进制 11xxxxxx)
</code></pre>
<ol>
<li> <strong>提供多种立体声模式</strong>: YASP 定义了一个枚举 <code>ay_stereo_mode_t</code>，包含了多种流行的 ZX-Spectrum 立体声配置：</li>
</ol>
<ul>
<li>  <code>AY_STEREO_ABC</code>: 左-中-右</li>
<li>  <code>AY_STEREO_ACB</code>: 左-右-中</li>
<li>  <code>AY_STEREO_BAC</code>: 中-左-右</li>
<li>  <code>AY_STEREO_MONO</code>: 全部居中</li>
</ul>
<ol>
<li> <strong>动态切换逻辑</strong>: <code>ay_to_opm_set_stereo_mode</code> 函数是实现动态切换的核心。当用户通过键盘（<code>Tab</code> 键）切换模式时，此函数被调用。</li>
</ol>
<pre><code class="language-     ```c">        void ay_to_opm_set_stereo_mode(ay_stereo_mode_t mode) {
            _current_stereo_mode = mode;
            // ...
            switch (mode) {
                case AY_STEREO_ABC:
                    ch_pan[0] = OPM_PAN_LEFT; ch_pan[1] = OPM_PAN_CENTER; ch_pan[2] = OPM_PAN_RIGHT;
                    break;
                // ... 其他模式 ...
            }
            // 将计算出的声像值应用到 OPM 的 4, 5, 6 通道
            for (int i = 0; i &lt; 3; i++) {
                int opmCh = toOpmCh(i);
                _y(0x20 + opmCh, (ch_pan[i] &amp; 0xC0) | 0x3C);
            }
            // 同时更新噪声的声像
            _updateNoise();
        }
</code></pre>
<ol>
<li> <strong>智能噪声声像</strong>: 噪声通道的声像处理尤为智能。<code>_updateNoise</code> 函数会检查所有三个 PSG 通道，如果其中有任何一个通道开启了噪声，它就会根据该通道的声像设置来决定噪声的最终位置。例如，如果通道 A（左声道）和通道 C（右声道）都开启了噪声，那么最终的噪声就会被设置为中央声道，以提供一个平衡的听感。</li>
</ol>
<ul>
<li>  <strong>成果</strong>: 这项独家功能极大地增强了 AY-8910 音乐的表现力。原本单调的单声道音乐，现在可以通过不同的立体声配置展现出丰富的空间感和层次感，为听者带来了全新的体验。用户可以根据自己的喜好实时切换，找到最适合当前曲目的立体声效果。</li>
</ul>
<h3 id="4-3">4.3. 高级计时与刷新系统</h3>
<p><a id="4-3"></a></p>
<p>YASP 的播放精度和稳定性由“刷新模式”和“定时器模式”共同决定。</p>
<h4 id="4-3-1">4.3.1. 刷新模式 (Flush Mode)</h4>
<p><a id="4-3-1"></a></p>
<p>刷新模式决定了播放器将寄存器数据发送到 SPFM 硬件的<strong>粒度</strong>。</p>
<table>
<thead>
<tr>
<th>模式 (按键)</th>
<th>名称</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>寄存器级 (Register-Level)</td>
<td><strong>每一次</strong>寄存器写入后，立刻调用 <code>spfm_flush()</code>。这保证了最高的实时性，但 USB 通信开销巨大。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>命令级 (Command-Level)</strong></td>
<td>仅在处理完一个完整的 VGM 命令后（如 <code>0x61 nn nn</code> 这样的等待命令，或一个芯片写入命令），才调用 <code>spfm_flush()</code>。这是<strong>性能和实时性的最佳平衡</strong>，也是默认设置。</td>
</tr>
</tbody>
</table>
<h4 id="4-3-2">4.3.2. 定时器模式 (Timer Mode)</h4>
<p><a id="4-3-2"></a></p>
<p>定时器模式决定了播放器在处理完 VGM 命令后，如何精确地<strong>等待</strong>到下一个事件发生。所有模式都基于高精度性能计数器 (<code>QueryPerformanceCounter</code>) 进行误差补偿。</p>
<table>
<thead>
<tr>
<th>模式 (按键)</th>
<th>源码名称</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>3</strong></td>
<td>High-Precision Sleep</td>
<td>调用 <code>Sleep(1)</code> 等待，并用性能计数器补偿其巨大的不精确性。适用于低负载环境。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Hybrid Sleep</td>
<td>使用 <code>CreateWaitableTimer</code> 等待 1ms，并补偿误差。比 <code>Sleep(1)</code> 更精确。</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>Multimedia Timer</td>
<td>使用 <code>timeSetEvent</code> 设置一个 1ms 的高精度多媒体定时器。播放线程等待该定时器触发的事件。精度高，但高负载下事件可能延迟。</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong>VGMPlay Mode</strong></td>
<td>“忙等”的变体，不断调用 <code>Sleep(0)</code> 让出时间片，响应极快，但 CPU 占用率极高。</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><strong>Optimized VGMPlay Mode</strong></td>
<td>模式 5 的优化版，增加了“防失控”机制，防止声音滞后和崩溃。<strong>这是默认和最佳选择。</strong></td>
</tr>
</tbody>
</table>
<h4 id="4-3-3">4.3.3. 定时器核心源码详解</h4>
<p><a id="4-3-3"></a></p>
<p>以下是 <code>util.c</code> 中 <code>yasp_usleep</code> 函数针对不同模式的核心实现：</p>
<p><strong>模式 3: High-Precision Sleep</strong></p>
<pre><code class="language-c">case 0: // High-Precision Sleep
    tick_to_wait = get_tick() + us_to_tick(us);
    while (get_tick() &lt; tick_to_wait) {
        Sleep(1);
    }
    break;
</code></pre>
<p><strong>解说</strong>: 这是最简单的实现。循环调用 <code>Sleep(1)</code>，每次让出至少 1ms 的时间片，直到性能计数器达到目标时间。<code>Sleep</code> 的精度很差，但 CPU 占用率低。</p>
<p><strong>模式 4: Hybrid Sleep</strong></p>
<pre><code class="language-c">case 1: // Hybrid Sleep
    tick_to_wait = get_tick() + us_to_tick(us);
    while (get_tick() &lt; tick_to_wait) {
        WaitForSingleObject(g_waitable_timer, 1);
    }
    break;
</code></pre>
<p><strong>解说</strong>: 使用 Windows 的可等待定时器 <code>WaitForSingleObject</code> 等待 1ms。它比 <code>Sleep(1)</code> 更精确，是精度和 CPU 占用的一个折中。</p>
<p><strong>模式 5: Multimedia Timer</strong></p>
<pre><code class="language-c">case 2: // Multimedia Timer
    tick_to_wait = get_tick() + us_to_tick(us);
    while (get_tick() &lt; tick_to_wait) {
        WaitForSingleObject(g_timer_event, 1);
    }
    break;
</code></pre>
<p><strong>解说</strong>: 依赖于一个由 <code>timeSetEvent</code> 创建的、在后台每 1ms 触发一次的 <code>g_timer_event</code> 事件。线程等待这个事件，精度很高。</p>
<p><strong>模式 6: VGMPlay Mode</strong></p>
<pre><code class="language-c">case 3: // VGMPlay Mode
    tick_to_wait = get_tick() + us_to_tick(us);
    while (get_tick() &lt; tick_to_wait) {
        Sleep(0);
    }
    break;
</code></pre>
<p><strong>解说</strong>: 这是“忙等”的一种形式。<code>Sleep(0)</code> 会让当前线程立即放弃剩余的时间片，让其他线程运行。这使得循环检测时间的频率非常高，响应极快，但会持续占用 CPU。</p>
<p><strong>模式 7: Optimized VGMPlay Mode</strong></p>
<p>此模式的优化不在 <code>yasp_usleep</code> 中，而在 <code>play.c</code> 的 <code>vgm_play</code> 函数里。它使用与模式 5 相同的等待机制，但增加了“防失控”逻辑：</p>
<pre><code class="language-c">// 在 play.c 的 vgm_play 中
if (g_timer_mode == 7) {
    vgm_slice_to_do = min(vgm_slice_to_do, g_vgm_slice_limiter);
}
</code></pre>
<p><strong>解说</strong>: 如果因为系统繁忙导致定时器事件严重延迟，积压了大量需要播放的样本 (<code>vgm_slice_to_do</code>)，此代码会将其限制在一个最大值 (<code>g_vgm_slice_limiter</code>) 内。这可以防止声音出现长时间的滞后，并快速追上实时进度，代价是丢弃少量积压的样本。</p>
<h3 id="4-4">4.4. SPFM 通信协议</h3>
<p><a id="4-4"></a></p>
<p>YASP 通过 FTDI D2XX 驱动与 SPFM 硬件通信。其核心是<strong>写入缓冲机制</strong>和<strong>混合等待策略</strong>。对于极短的等待（<10个样本），发送硬件等待命令 <code>0x80</code>；对于较长的等待，则调用由上述定时器模式决定的高精度软件等待函数 <code>yasp_usleep</code>。</p>
<h2 id="5">5. 性能优化-版本对比</h2>
<p><a id="5"></a></p>
<p>在开发过程中，我们发现当前版本（修复前）相比于旧的 <code>console_player862</code> 版本，在文件浏览器的操作流畅度和音乐播放的顺滑度上存在明显退步。本章节旨在深入分析其根本原因，并详细阐述为解决这些问题而实施的优化措施。</p>
<h3 id="5-1">5.1. 问题根源：为什么旧版本更快？</h3>
<p><a id="5-1"></a></p>
<p>经过对 <code>console_player862</code> 源码的分析，我们定位了导致性能下降的两个核心原因：</p>
<p><strong>1. 同步的文件系统读取阻塞了主线程</strong></p>
<ul>
<li>  <strong>旧版本 (<code>862</code>) 行为</strong>: 文件浏览器在独立的线程中异步加载目录内容。这意味着即使用户进入一个包含数千个文件的庞大目录，主线程（负责UI渲染和键盘输入）也<strong>不会被阻塞</strong>，界面始终保持响应。</li>
<li>  <strong>新版本（修复前）行为</strong>: 文件浏览器在主线程中<strong>同步地</strong>调用 <code>scandir</code>。当 <code>scandir</code> 遍历一个大目录时，它会花费数百毫秒甚至数秒的时间，在此期间，整个程序完全冻结，无法响应任何用户输入，也无法刷新UI，导致了严重的卡顿感。</li>
</ul>
<p><strong>2. 低效的UI刷新机制</strong></p>
<ul>
<li>  <strong>旧版本 (<code>862</code>) 行为</strong>: UI的刷新是<strong>事件驱动</strong>的。只有在播放状态改变（如切换歌曲、暂停）或用户有输入时，才会触发 <code>update_ui()</code> 函数，重绘界面。这种方式极为高效。</li>
<li>  <strong>新版本（修复前）行为</strong>: UI的刷新被置于一个<strong>固定的、高频率的循环</strong>中。无论状态是否改变，主循环都会以极高的频率（每隔几毫秒）调用 <code>update_ui()</code>，导致了大量的冗余计算和屏幕重绘。这不仅浪费了CPU资源，还可能与播放线程的计时器发生冲突，影响播放的稳定性。</li>
</ul>
<h3 id="5-2">5.2. 修复措施：如何恢复并超越旧版性能</h3>
<p><a id="5-2"></a></p>
<p>针对上述问题，我们实施了以下关键优化：</p>
<p><strong>1. 引入异步文件列表加载 (<code>browser.c</code>)</strong></p>
<p>我们重构了文件浏览器，恢复并改进了异步加载机制。</p>
<pre><code class="language-c">// 在 browser.c 中
static bool g_loading_thread_active = false;
static HANDLE g_loading_thread_handle = NULL;

// 当用户进入一个目录时，不再直接扫描，而是创建一个新线程
void refresh_file_list(const char* path) {
    // ...
    g_loading_thread_handle = CreateThread(NULL, 0, loading_thread_func, new_path, 0, NULL);
    // ...
}

// 新的加载线程负责执行耗时的 scandir 操作
static DWORD WINAPI loading_thread_func(LPVOID lpParam) {
    g_loading_thread_active = true;
    // ...
    int n = scandir(path, &amp;g_namelist, 0, alphasort); // 耗时操作在这里执行
    // ...
    g_loading_thread_active = false;
    return 0;
}
</code></pre>
<p><strong>解说</strong>: 当用户选择一个目录时，主函数 <code>refresh_file_list</code> 不再自己执行 <code>scandir</code>，而是立即返回，并将这个耗时操作交给一个新创建的 <code>loading_thread_func</code> 线程去完成。在加载期间，<code>g_loading_thread_active</code> 标志位被设为 <code>true</code>，UI可以据此显示“正在加载...”的提示，而主线程本身保持流畅，可以随时响应用户操作。</p>
<p><strong>2. 实现事件驱动的UI刷新 (<code>main.c</code>, <code>play.c</code>)</strong></p>
<p>我们彻底移除了主循环中无效的、高频率的UI重绘调用，并引入了一个全局标志 <code>g_ui_refresh_request</code>。</p>
<pre><code class="language-c">// 在 main.c 的主循环中
int main() {
    // ...
    while (!g_quit_flag) {
        if (g_ui_refresh_request) {
            update_ui(...);
            g_ui_refresh_request = false; // 重绘后立即清除标志
        }
        // ... 处理键盘输入 ...
        yasp_usleep(16000); // 主循环现在可以轻松地休眠
    }
    // ...
}
</code></pre>
<p><strong>解说</strong>: <code>update_ui()</code> 现在只有在 <code>g_ui_refresh_request</code> 为 <code>true</code> 时才会被调用。这个标志仅在真正需要更新UI的时刻被设置，例如：</p>
<ul>
<li>  歌曲开始播放时 (<code>play_file</code>)</li>
<li>  用户暂停/继续、切换模式时 (<code>main.c</code> 的键盘处理部分)</li>
<li>  文件浏览器完成加载时 (<code>browser.c</code>)</li>
</ul>
<p>这种<strong>事件驱动</strong>的模式，将UI刷新的频率从每秒数百次降低到了必要的几次，极大地降低了CPU占用，并从根本上解决了UI刷新与播放计时器之间的潜在冲突。</p>
<p>通过以上两项核心优化，YASP不仅恢复了旧版本 <code>862</code> 的流畅体验，还在代码结构和可维护性上取得了进一步的提升。</p>
<h2 id="6">6. 操作指南</h2>
<p><a id="6"></a></p>
<p>YASP 的操作完全通过键盘进行。界面分为<strong>播放器主界面</strong>和<strong>文件浏览器</strong>。</p>
<h3 id="6-1">6.1. 播放器主界面</h3>
<p>播放器主界面实时显示当前播放的音乐信息、播放器状态和硬件配置。</p>
<h4 id="6-1-1">6.1.1. 界面布局 (ASCII 简图)</h4>
<pre><code class="language-">+------------------------------------------------------------------------------+
| YASP - Yet Another Sound Player                               (行 0)         |
| --------------------------------------------------            (行 1)         |
| Track: [当前曲目名称]                                         (行 2)         |
| Game: [所属游戏名称]                                          (行 3)         |
| System: [游戏平台]                                            (行 4)         |
| Author: [作曲家]                                              (行 5)         |
| Date: [发行日期]                                              (行 6)         |
| VGM By: [VGM 文件制作者]                                      (行 7)         |
| VGM Chip: [芯片类型] ([时钟频率]MHz)                          (行 8)         |
| Status: [Playing.../Paused]                                   (行 9)         |
| Total Time: [总时长] | Loops: [循环次数]                      (行 10)        |
| Flush Mode (1,2): [刷新模式]                                  (行 11)        |
| Timer (3-7): [定时器模式]                                     (行 12)        |
| Mode: [播放模式] | Speed: [播放速度]x                         (行 13)        |
| OPN LFO Amp: [LFO 幅度]                                       (行 14)        |
| Slot 0: [芯片0] | Slot 1: [芯片1]                             (行 15)        |
| Conversion: [转换状态]                                        (行 16)        |
| --------------------------------------------------            (行 17)        |
| [按键说明]                                                    (行 18)        |
+------------------------------------------------------------------------------+
</code></pre>
<h4 id="6-1-2">6.1.2. 界面说明</h4>
<ul>
<li>  <strong>行 2-7</strong>: 显示从 VGM 文件的 GD3 标签中读取的元数据。如果标签不存在，则显示文件名。</li>
<li>  <strong>行 8 (VGM Chip)</strong>: 显示 VGM 文件原始指定的音源芯片及其时钟频率。</li>
<li>  <strong>行 9 (Status)</strong>: 显示当前是正在播放还是已暂停。</li>
<li>  <strong>行 10 (Total Time / Loops)</strong>: 显示计算出的总播放时长（包含循环）和用户设定的循环次数。</li>
<li class="toc-level-3">  <strong>行 11 (Flush Mode)</strong>: 数据发送到 SPFM 的刷新策略（详见 <a href="#4-3-1">4.3.1</a>）。</li>
<li class="toc-level-3">  <strong>行 12 (Timer)</strong>: 播放器使用的等待策略（详见 <a href="#4-3-2">4.3.2</a>）。</li>
<li>  <strong>行 13 (Mode / Speed)</strong>: 显示当前是顺序播放还是随机播放，以及播放速度倍率。</li>
<li>  <strong>行 14 (OPN LFO Amp)</strong>: 仅在进行 OPN->OPM 转换时显示，用于调整 LFO 效果的强度。</li>
<li>  <strong>行 15 (Slot 0 / Slot 1)</strong>: 显示 SPFM 硬件上两个插槽实际安装的芯片类型。</li>
<li>  <strong>行 16 (Conversion)</strong>: 显示当前的播放方式（直接播放、实时转换或使用缓存）。</li>
</ul>
<h3 id="6-2">6.2. 文件浏览器</h3>
<p>在主界面按 <code>f</code> 键可进入文件浏览器。</p>
<pre><code class="language-">+------------------------------------------------------------------------------+
| Path: [当前路径]                                                             |
| --------------------------------------------------                           |
| &gt; [.]                                                                        |
|   [..]                                                                       |
|   [目录1]/                                                                   |
|   [文件1.vgm]                                                                |
|   [文件2.s98]                                                                |
|   ...                                                                        |
+------------------------------------------------------------------------------+
</code></pre>
<ul>
<li>  使用 <code>上/下</code> 方向键选择文件或目录。</li>
<li>  按 <code>回车</code> 键播放选中的文件或进入选中的目录。</li>
<li>  按 <code>f</code> 键可随时关闭浏览器，返回播放器主界面。</li>
</ul>
<h3 id="6-3">6.3. 按键说明</h3>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>q</code></td>
<td><strong>退出程序</strong></td>
<td></td>
</tr>
<tr>
<td><code>p</code></td>
<td><strong>暂停 / 继续</strong></td>
<td>切换播放状态。</td>
</tr>
<tr>
<td><code>n</code></td>
<td><strong>下一首</strong></td>
<td>立即切换到播放列表的下一首歌曲。</td>
</tr>
<tr>
<td><code>b</code></td>
<td><strong>上一首</strong></td>
<td>立即切换到播放列表的上一首歌曲。</td>
</tr>
<tr>
<td><code>r</code></td>
<td><strong>切换播放模式</strong></td>
<td>在“顺序播放”和“随机播放”之间切换。</td>
</tr>
<tr>
<td><code>f</code></td>
<td><strong>打开/关闭文件浏览器</strong></td>
<td></td>
</tr>
<tr>
<td><code>+</code> / <code>-</code></td>
<td><strong>调整播放速度</strong></td>
<td>以 0.05 为步进增加或减少速度倍率。</td>
</tr>
<tr>
<td><code>上/下</code></td>
<td><strong>调整 OPN LFO 幅度</strong></td>
<td>仅在 OPN->OPM 转换时有效，用于实时增强或减弱 LFO 效果。</td>
</tr>
<tr>
<td><code>左/右</code></td>
<td><strong>调整循环次数</strong></td>
<td>减少或增加歌曲的循环播放次数。</td>
</tr>
<tr>
<td><code>1</code> / <code>2</code></td>
<td><strong>切换刷新模式</strong></td>
<td>在“寄存器级”和“命令级”刷新之间切换。</td>
</tr>
<tr>
<td><code>3</code> - <code>7</code></td>
<td><strong>切换定时器模式</strong></td>
<td>切换不同的计时策略，以适应不同的系统负载。</td>
</tr>
</tbody>
</table>
<h2 id="7">7. 编译与构建</h2>
<p><a id="7"></a></p>
<p>YASP 项目使用 <code>make</code> 进行构建，依赖于 <code>MinGW-w64</code> 编译环境和 FTDI 官方的 <code>D2XX</code> 驱动库。</p>
<h3 id="7-1">7.1. 环境要求</h3>
<ul>
<li>  <strong>编译器</strong>: <code>MinGW-w64</code> (推荐使用 <code>x86_64-w64-mingw32</code> 版本，以支持 64 位编译)。</li>
<li>  <strong>构建工具</strong>: <code>make</code> (通常与 MinGW-w64 一同安装)。</li>
<li>  <strong>依赖库</strong>:</li>
<li>  <code>ftd2xx.h</code>: FTDI D2XX 驱动头文件，需放置在 <code>console_player</code> 目录下。</li>
<li>  <code>ftd2xx64.dll</code>: 64 位 FTDI D2XX 动态链接库，需放置在 <code>console_player</code> 目录下。</li>
</ul>
<h3 id="7-2">7.2. Makefile 详解</h3>
<p>项目根目录下的 <code>console_player/makefile</code> 文件定义了所有构建规则。</p>
<ul>
<li>  <strong><code>CC</code></strong>: 定义 C 编译器，默认为 <code>gcc</code>。</li>
<li>  <strong><code>CFLAGS</code></strong>: 编译标志。</li>
<li>  <code>-m64</code>: 生成 64 位代码。</li>
<li>  <code>-Wall</code>, <code>-Wextra</code>: 开启所有标准和额外的警告，以提高代码质量。</li>
<li>  <code>-g</code>: 生成调试信息，方便使用 GDB 等工具进行调试。</li>
<li>  <code>-O0</code>: 关闭所有优化，确保调试时代码行为与源码完全一致。</li>
<li>  <code>-I"../ftdi_driver"</code>: 将 <code>ftdi_driver</code> 目录添加到头文件搜索路径，以便找到 <code>ftd2xx.h</code>。</li>
<li>  <strong><code>LDFLAGS</code></strong>: 链接器标志，在链接阶段传递给编译器。</li>
<li>  <code>-m64</code>: 创建一个 64 位的可执行文件。</li>
<li>  <code>-s</code>: 从最终的可执行文件中剥离符号表和重定位信息，以减小文件大小。</li>
<li>  <code>-L"../ftdi_driver/amd64"</code>: 将 <code>ftdi_driver/amd64</code> 目录添加到库搜索路径，以便链接器找到 <code>libftd2xx.a</code>。</li>
<li>  <strong><code>LIBS</code></strong>: 需要链接的库文件。</li>
<li>  <code>-lftd2xx</code>: 链接 FTDI D2XX 驱动库，用于与 SPFM 硬件通信。</li>
<li>  <code>-lm</code>: 链接数学库 (<code>libm</code>)，提供 <code>log2</code> 等数学函数，用于频率转换。</li>
<li>  <code>-lwinmm</code>: (仅 Windows) 链接 Windows 多媒体库 (<code>winmm.lib</code>)，提供 <code>timeSetEvent</code> 等高精度定时器功能。</li>
<li>  <code>-lavrt</code>: (仅 Windows) 链接多媒体类计划程序服务库 (<code>avrt.lib</code>)，允许将播放线程的优先级提升到“Pro Audio”级别，以减少音频抖动。</li>
<li>  <code>-lole32</code>: (仅 Windows) 链接 OLE32 库，提供 COM 服务，是 <code>avrt</code> 库的依赖项。</li>
<li>  <code>-lpthread</code>: (仅 POSIX 系统如 Linux) 链接 POSIX 线程库，用于创建和管理线程。</li>
<li>  <strong><code>SOURCES</code></strong>: 定义了所有需要编译的 <code>.c</code> 源文件。</li>
<li>  <strong><code>OBJECTS</code></strong>: 根据 <code>SOURCES</code> 自动生成对应的 <code>.o</code> 目标文件列表。</li>
<li>  <strong><code>TARGET</code></strong>: 定义了最终生成的可执行文件名，默认为 <code>yasp_test.exe</code>。</li>
</ul>
<h3 id="7-3">7.3. 构建与运行</h3>
<ol>
<li> <strong>执行构建</strong>: 打开终端，在<strong>项目根目录</strong> (<code>yasp</code>) 下运行 <code>make</code> 命令，并使用 <code>-C</code> 参数指定 <code>makefile</code> 所在的目录。</li>
</ol>
<pre><code class="language- ```bash">    make -C console_player
</code></pre>
<p>    <code>make</code> 会自动根据 <code>console_player/makefile</code> 的规则，编译所有源文件，并最终在 <code>console_player</code> 目录下生成 <code>yasp_test.exe</code>。</p>
<ol>
<li> <strong>运行程序</strong>:</li>
</ol>
<pre><code class="language- ```bash">    ./console_player/yasp_test.exe
</code></pre>
<ol>
<li> <strong>清理构建文件</strong>: 如果需要重新编译所有文件，可以运行 <code>make clean</code>。</li>
</ol>
<pre><code class="language- ```bash">    make -C console_player clean
</code></pre>
<p>    此命令会删除 <code>console_player</code> 目录中所有生成的 <code>.o</code> 目标文件和 <code>yasp_test.exe</code> 可执行文件。</p>
<hr>
<h2 id="8">8. 故障排查与更新日志</h2>
<p><a id="8"></a></p>
<h3 id="8-1">8.1. 故障排查：播放时不受控制地快速切换曲目</h3>
<p><a id="8-1"></a></p>
<p>在开发芯片转换和缓存功能时，我们遇到了一个非常棘手的 bug：当播放需要实时转换的 VGM 文件（如 OPN -> OPM）时，程序会立即结束当前曲目，并“自动跳转”到播放列表的下一首，导致无法正常听完任何一首需要转换的音乐。</p>
<h4 id="8-1-1">8.1.1. 诊断过程</h4>
<p><a id="8-1-1"></a></p>
<p>经过与项目所有者 <strong>Denjhang</strong> 的多次、细致的联调，我们排除了多种可能性，最终将问题定位在缓存文件的创建流程上。</p>
<ol>
<li> <strong>初步怀疑：文件指针混乱</strong></li>
</ol>
<ul>
<li>  最初，我们怀疑在创建缓存文件时，读写操作混用了同一个文件指针 <code>FILE*</code>，导致文件流状态错乱。</li>
<li>  <strong>修复尝试</strong>：引入了“先将整个 VGM 文件读入内存，再从内存进行转换和写入”的策略。这虽然从架构上解决了指针混用的隐患，并成功保留了 GD3 标签，但“自动跳转”的问题依然存在。</li>
</ul>
<ol>
<li> <strong>深入分析：<code>fopen</code> 的静默失败</strong></li>
</ol>
<ul>
<li>  在代码逻辑中，程序会尝试以写入模式 (<code>"wb"</code>) 打开一个新的缓存文件。然而，我们忽略了一个 C 语言标准库的关键行为：如果 <code>fopen</code> 尝试在一个<strong>不存在的目录</strong>中创建文件，它会<strong>直接失败并返回 <code>NULL</code></strong>，而不会自动创建目录。</li>
<li>  <strong>关键线索</strong>：项目所有者 <strong>Denjhang</strong> 敏锐地观察到：“<strong>我发现没有生成任何缓冲文件</strong>”。这个线索是整个问题得以解决的决定性转折点。它直接证明了 <code>fopen(cache_filename, "wb")</code> 这个调用已经失败。</li>
</ul>
<ol>
<li> <strong>最终根源定位</strong></li>
</ol>
<ul>
<li>  当 <code>fopen</code> 失败后，后续的代码逻辑没有进行充分的 <code>NULL</code> 检查，导致程序继续使用一个无效的、为 <code>NULL</code> 的文件句柄进行后续的播放操作。</li>
<li>  当播放线程 (<code>vgm_player_thread</code>) 尝试从这个 <code>NULL</code> 文件句柄中读取数据时，<code>fread</code> 或其他文件操作函数会立即返回错误（通常是 0 或 -1），这使得播放循环的退出条件 <code>g_is_playing = false</code> 被瞬间触发。</li>
<li>  主播放循环检测到 <code>g_is_playing</code> 变为 <code>false</code>，便认为当前歌曲已“播放完毕”，于是自然地切换到下一首。这就完美解释了“不受控制地快速切换曲目”的现象。</li>
</ul>
<h4 id="8-1-2">8.1.2. 最终解决方案</h4>
<p><a id="8-1-2"></a></p>
<p>解决方案非常直接：在调用 <code>fopen</code> 创建缓存文件之前，<strong>强制确保 <code>cache</code> 目录一定存在</strong>。</p>
<p>我们在 <code>vgm.c</code> 的 <code>vgm_play</code> 函数中，加入了平台相关的目录创建代码：</p>
<pre><code class="language-c">// 在 vgm.c 的 vgm_play 函数中，尝试创建缓存文件之前
// --- CACHE DOES NOT EXIST, CREATE IT ---
logging(INFO, &quot;Cache not found. Converting %s to OPM...&quot;, chip_type_to_string(g_vgm_chip_type));

#ifdef _WIN32
    _mkdir(&quot;console_player/cache&quot;);
#else
    mkdir(&quot;console_player/cache&quot;, 0755);
#endif

// 之后再安全地调用 fopen
g_cache_fp = fopen(cache_filename, &quot;wb&quot;);
if (!g_cache_fp) {
    // ... 错误处理 ...
}
</code></pre>
<p><strong>解说</strong>: 这段代码利用 <code>_mkdir</code> (Windows) 或 <code>mkdir</code> (Linux/macOS) 来尝试创建 <code>console_player/cache</code> 目录。如果目录已经存在，这个调用会被安全地忽略；如果不存在，它会被创建。这确保了后续的 <code>fopen</code> 调用总能在一个有效的路径下执行，从而从根本上解决了文件创建失败的问题。</p>
<p>这个案例深刻地揭示了在进行底层文件 I/O 操作时，对<strong>前置条件（如目录存在性）进行校验</strong>的重要性。</p>
<h3 id="8-2">8.2. Bug 修复与改进日志 (v0.881)</h3>
<p><a id="8-2"></a></p>
<p>本次更新修复了多个关键问题，并对核心功能进行了改进：</p>
<h4 id="8-2-1">8.2.1. 修复了转换后 VGM 文件的循环逻辑</h4>
<p><a id="8-2-1"></a></p>
<ul>
<li>  <strong>问题</strong>: 转换后的缓存 VGM 文件（例如，从 YM2612 转换到 YM2151）没有正确继承原始文件的循环点，而是强制从文件头开始循环。</li>
<li>  <strong>修复过程</strong>:</li>
</ul>
<ol>
<li> 在 <code>vgm.c</code> 中引入了 <code>g_original_loop_offset</code> 和 <code>g_converted_loop_offset</code> 两个全局变量，用于在转换过程中追踪循环点的位置。</li>
<li> 修改了 <code>vgm_convert_and_cache_from_mem</code> 函数。在遍历原始 VGM 数据流时，检查当前的文件指针是否到达了原始头部记录的循环点 (<code>g_original_loop_offset</code>)。</li>
<li> 当到达该点时，记录下当前<strong>缓存文件</strong>的写入位置 (<code>ftell(g_cache_fp)</code>) 到 <code>g_converted_loop_offset</code>。</li>
<li> 最后，在 <code>vgm_play</code> 函数中，当回写缓存文件的头部信息时，使用这个新计算出的 <code>g_converted_loop_offset</code> 作为新的循环起始点，从而确保了循环的准确性。</li>
</ol>
<h4 id="8-2-2">8.2.2. 修复了播放完成后的自动切歌问题</h4>
<p><a id="8-2-2"></a></p>
<ul>
<li>  <strong>问题</strong>: 在某些情况下（尤其是在播放期间按过“下一首”或“上一首”之后），一首歌曲在完成所有循环后不会自动切换到播放列表的下一首。</li>
<li>  <strong>修复过程</strong>:</li>
</ul>
<ol>
<li> 问题定位在 <code>main.c</code> 的 <code>player_thread_func</code> 线程函数中。</li>
<li> 原逻辑在 <code>play_file</code> 函数返回后，会检查 <code>g_next_track_flag</code> 等标志位。如果这些标志位被置位，它会错误地将 <code>g_is_playing</code> 设为 <code>false</code> 并中断播放循环。</li>
<li> 修改了该逻辑判断。现在，如果歌曲是自然播放结束（即没有被用户手动切歌中断），它会正常地获取下一首歌的索引并继续播放。如果歌曲是被用户中断的，则由主循环的其他部分来处理切歌逻辑，避免了线程的提前退出。</li>
</ol>
<h4 id="8-2-3">8.2.3. 修正了 UI 中总时间的计算</h4>
<p><a id="8-2-3"></a></p>
<ul>
<li>  <strong>问题</strong>: UI 显示的“Total Time”没有将循环次数计算在内，导致显示的时间与实际播放时间不符。</li>
<li>  <strong>修复过程</strong>: 在 <code>play.c</code> 的 <code>update_ui</code> 函数中，修改了总时间的计算公式。新的计算方式为：<code>总样本数 + (循环部分样本数 * (循环次数 - 1))</code>。这样，显示的总时间就能准确反映包括所有循环在内的完整播放时长。</li>
</ul>
<h4 id="8-2-4">8.2.4. 修正了 UI 中 VGM 芯片信息的显示</h4>
<p><a id="8-2-4"></a></p>
<ul>
<li>  <strong>问题</strong>: 当播放一个经过转换的缓存文件时，UI 的“VGM Chip”字段显示的是目标芯片（如 YM2151），而不是原始 VGM 文件中记录的芯片（如 YM2612）。</li>
<li>  <strong>修复过程</strong>:</li>
</ul>
<ol>
<li> 在 <code>vgm.c</code> 中，当解析头部时，除了 <code>g_vgm_chip_type</code> 外，还使用 <code>g_original_vgm_chip_type</code> 来专门存储原始文件的芯片类型。</li>
<li> 在 <code>play.c</code> 的 <code>update_ui</code> 函数中，修改了显示逻辑。现在它会检查 <code>g_is_playing_from_cache</code> 标志。如果正在播放缓存文件，则强制使用 <code>g_original_vgm_chip_type</code> 和原始头部信息来显示芯片名称和时钟频率。</li>
</ol>
<h4 id="8-2-5">8.2.5. 增加了对无效 VGM 文件的检测</h4>
<p><a id="8-2-5"></a></p>
<ul>
<li>  <strong>问题</strong>: 对于头部信息不完整或损坏的 VGM 文件（例如所有芯片时钟都为 0），播放器仍然会尝试猜测一个时钟频率并播放，这可能导致不正确的行为。</li>
<li>  <strong>修复过程</strong>: 在 <code>play.c</code> 的 <code>update_ui</code> 函数中，增加了一个检查。在显示芯片信息前，它会判断 VGM 头部中所有已知芯片的时钟是否都为 0。如果是，则直接显示 "VGM Chip: Invalid/Unsupported"，向用户明确指出文件可能存在问题。</li>
</ul>
<h3 id="8-3">8.3. 功能改进与错误修复 (v0.884)</h3>
<p><a id="8-3"></a></p>
<p>本次更新着重于改善用户体验、启动逻辑和文件管理的健壮性。</p>
<h4 id="8-3-1">8.3.1. 启动流程与目录管理优化</h4>
<p><a id="8-3-1"></a></p>
<ul>
<li>  <strong>自动创建目录</strong>: 程序在启动时会检查 <code>music</code> 和 <code>cache</code> 目录是否存在。如果不存在，会自动创建它们，避免了因缺少目录而导致的潜在错误。</li>
<li>  <strong>智能音乐扫描</strong>:</li>
<li>  程序会首先检查配置文件 (<code>config.ini</code>) 中的 <code>last_file</code> 记录是否有效。如果文件不存在，该记录会被视为无效。</li>
<li>  如果 <code>last_file</code> 无效，程序会优先扫描 <code>music</code> 目录。</li>
<li>  如果 <code>music</code> 目录为空，程序会回退到扫描其所在的当前工作目录，以确保能发现可播放的音乐。</li>
<li>  <strong>无音乐时直接进入浏览器</strong>: 如果在所有默认路径下都未找到任何支持的音乐文件，程序不再直接退出，而是自动进入文件浏览器模式，方便用户手动定位音乐文件。</li>
</ul>
<h4 id="8-3-2">8.3.2. 文件浏览器功能增强</h4>
<p><a id="8-3-2"></a></p>
<ul>
<li>  <strong>上下文感知启动</strong>: 在播放器主界面按 <code>f</code> 键进入文件浏览器时，浏览器将自动定位到当前正在播放歌曲所在的目录，而不是总是从程序主目录开始，极大地提升了操作的便捷性。</li>
<li>  <strong>路径分隔符统一</strong>: 浏览器内部所有路径处理都统一使用正斜杠 (<code>/</code>)，解决了在 Windows 平台下因混合使用正反斜杠 (<code>\</code> 和 <code>/</code>) 可能导致的路径解析问题。</li>
<li>  <strong>上级目录导航修复</strong>: 修复了在文件系统的根目录（如 <code>C:/</code>）下选择 <code>..</code> 会错误地跳转到驱动器列表的问题。现在，在根目录下进行向上导航操作将被正确地忽略。</li>
</ul>
<h4 id="8-3-3">8.3.3. 增加清理缓存功能</h4>
<p><a id="8-3-3"></a></p>
<ul>
<li>  在芯片选择流程完成后，程序会提示用户是否需要清理转换缓存。用户可以按 <code>y</code> 键来删除 <code>cache</code> 目录下的所有文件，这对于解决潜在的缓存污染问题或释放磁盘空间非常有用。</li>
</ul>
<h3 id="8-4">8.4. AY-8910 包络波形转换修复 (v0.888)</h3>
<p><a id="8-4"></a></p>
<p>本次更新解决了 AY-8910 (PSG) 到 YM2151 (OPM) 转换中的一个长期存在的关键 bug，使得某些特定类型的 AY-8910 音乐（尤其是使用包络作为波形发生器的 chiptune）能够被正确播放。</p>
<ul>
<li>  <strong>问题</strong>: 在某些 AY-8910 音乐中，作者会利用硬件包络的高速重复来生成一种特殊的“波形”，而不是用它来控制音量。在这种模式下，作者通常会关闭通道的方波输出开关。旧的转换逻辑错误地将“方波关闭”解读为“通道静音”，导致这些通道在转换后完全无声。</li>
<li>  <strong>修复过程</strong>:</li>
</ul>
<ol>
<li> <strong>定位核心错误</strong>: 通过与项目所有者 <strong>Denjhang</strong> 的反复调试和分析，最终确认问题根源在于 <code>ay_to_opm.c</code> 中的 <code>_updateTone</code> 函数。该函数仅在检测到方波开关打开时才计算音量，完全忽略了“仅包络输出”的特殊情况。</li>
<li> <strong>重构静音逻辑</strong>: 对 <code>_updateTone</code> 函数进行了重构。新的逻辑是：一个通道只要<strong>方波开关打开</strong>，<strong>或者</strong>它正处于<strong>用包络生成波形的模式</strong>（即包络模式开启且包络周期极短），就应该被视为是活动的，并为其计算音量。</li>
<li> <strong>代码实现</strong>:</li>
</ol>
<pre><code class="language-     ```c">        // ay_to_opm.c
        static void _updateTone(int ch) {
            const int v = _regs[8 + ch];
            const int tone_enabled = ((1 &lt;&lt; ch) &amp; _regs[7]) == 0;
            const int envelope_as_waveform = (v &amp; 0x10) &amp;&amp; (_envelope_period &lt; 200);

            int opmCh = toOpmCh(ch);

            if (tone_enabled || envelope_as_waveform) {
                // ... 计算并设置音量 ...
            } else {
                // 仅在两种情况都不满足时才静音
                _y(0x70 + opmCh, 0x7f);
            }
        }
</code></pre>
<ul>
<li>  <strong>成果</strong>: 经过此修复，之前在转换后静音的 AY-8910 bass 和其他特殊音效现在可以被正确地、响亮地播放出来，显著提升了对特殊 chiptune 曲目的兼容性。</li>
</ul>
<h3 id="8-5">8.5. AY-8910 快速琶音转换修复 (v0.903)</h3>
<p><a id="8-5"></a></p>
<p>本次更新解决了 AY-8910 (PSG) 到 YM2151 (OPM) 转换中一个关于快速音符序列（琶音）的严重 bug。</p>
<ul>
<li>  <strong>问题</strong>: 在播放包含快速琶音的 AY-8910 音乐时，转换后的 OPM 通道在播放约10秒后会出现音符丢失、无声的现象。经过 <code>vgm_parser</code> 工具的深入分析，发现问题出在 <code>ay_to_opm.c</code> 的音高和音符开关（Key On/Off）识别机制上。在快速的音高变化和通道开关切换下，旧的逻辑无法正确地重新触发音符，导致声音中断。</li>
<li>  <strong>修复过程</strong>:</li>
</ul>
<ol>
<li> <strong>重构混音器（R7）逻辑</strong>: 对 <code>ay_to_opm_write_reg</code> 函数中处理 AY-8910 寄存器 7（混音器）的部分进行了彻底重构。现在，代码能够精确地检测到每个通道的“音调使能”位从 1 到 0 的变化，这被视为一个明确的 <strong>Key-On</strong> 事件。</li>
<li> <strong>精确的 Key-On/Key-Off 处理</strong>:</li>
</ol>
<ul>
<li>  在检测到 <strong>Key-On</strong> 事件时，立即为该通道重新计算频率 (<code>_recalculate_freq</code>)、更新音量 (<code>_updateTone</code>)，并向 OPM 发送一个强制的“所有操作员打开”（Key On all slots）命令 (<code>_y(0x08, (0xf << 3) | opmCh)</code>)。</li>
<li>  同时，如果该通道使用的是一次性包络，则重置包络状态，确保每次音符触发时包络都能从头开始。</li>
<li>  在检测到 <strong>Key-Off</strong> 事件（音调使能位从 0 到 1）时，则向 OPM 发送一个“所有操作员关闭”的命令 (<code>_y(0x08, opmCh)</code>)。</li>
</ul>
<ol>
<li> <strong>简化幅度（R8-R10）逻辑</strong>: 移除了原先在处理幅度寄存器时复杂的、用于猜测 Key-On/Off 的逻辑。现在音符的开关完全由混音器（R7）的逻辑精确控制，使得代码更清晰、更可靠。</li>
</ol>
<ul>
<li>  <strong>成果</strong>: 经过此修复，AY-8910 转换后的快速琶音现在可以被完整、清晰地播放，不再出现中途掉音的问题，极大地提升了对复杂 chiptune 曲目的兼容性和保真度。</li>
</ul>

<script>
    window.onscroll = function() {
        updateProgressBar();
    };

    document.getElementById("progress-container").onclick = function(event) {
        var rect = this.getBoundingClientRect();
        var clickX = event.clientX - rect.left;
        var percentage = clickX / this.offsetWidth;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        window.scrollTo(0, height * percentage);
    };

    function updateProgressBar() {
        var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        var scrolled = (winScroll / height) * 100;
        document.getElementById("progress-bar").style.width = scrolled + "%";
    }
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YASP - Yet Another Sound Player</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            padding-bottom: 50px; /* Add padding to prevent content from being hidden by the progress bar */
        }
        #progress-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 8px;
            background-color: #f0f0f0;
            z-index: 1000;
            cursor: pointer;
        }
        #progress-bar {
            height: 100%;
            width: 0;
            background-color: #0366d6;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h3 { font-size: 1.25em; }
        h4 { font-size: 1em; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        code {
            padding: .2em .4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 3px;
        }
        pre code {
            display: inline;
            padding: 0;
            margin: 0;
            overflow: visible;
            line-height: inherit;
            word-wrap: normal;
            background-color: transparent;
            border: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1em;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid #dfe2e5;
            padding: 6px 13px;
        }
        th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        ul, ol { padding-left: 2em; }
        li { margin-top: .25em; }

        /* Hierarchical TOC styles */
        .toc-level-1 { font-weight: 500; }
        .toc-level-2 { margin-left: 1.5em; }
        .toc-level-3 { margin-left: 3em; }
        .toc-level-4 { margin-left: 4.5em; }
        .toc-level-1 > a { font-size: 1.1em; }
        .toc-level-2 > a { font-size: 1.0em; }
        .toc-level-3 > a { font-size: 0.95em; }
        .toc-level-4 > a { font-size: 0.9em; color: #333; }

        blockquote {
            margin-left: 0;
            padding-left: 1em;
            color: #6a737d;
            border-left: .25em solid #dfe2e5;
        }
    </style>
</head>
<body>
<div id="progress-container">
    <div id="progress-bar"></div>
</div>
<h1 id="yasp-yet-another-sound-player">YASP - Yet Another Sound Player</h1>
<h2 id="abstract">Abstract</h2>
<p>YASP (Yet Another Sound Player) is a command-line music player designed for the SPFM (Sound-Processing FM-synthesis) family of hardware. It focuses on efficiently and accurately playing classic VGM and S98 format music files, providing users with the ultimate retro audio experience through various configurable refresh modes and timer options.</p>
<hr>
<h2 id="table-of-contents">Table of Contents</h2>
<ol>
<li> <a href="#project-background">Project Background</a></li>
<li> <a href="#features">Features</a></li>
<li> <a href="#controls">Controls</a></li>
<li> <a href="#build-instructions">Build Instructions</a></li>
<li> <a href="#source-code-references">Source Code References</a></li>
</ol>
<hr>
<h2 id="body">Body</h2>
<h3 id="project-background">Project Background</h3>
<p>This project aims to create a powerful and highly customizable command-line music player for SPFM hardware enthusiasts. The development was a collaborative effort between the following members:</p>
<ul>
<li>  <strong>Denjhang (Project Owner/Lead Developer):</strong> Responsible for defining project requirements, core architecture design, providing key technical implementations (such as high-precision timer example code), and conducting final testing and validation.</li>
<li>  <strong>Cline (AI Software Engineer):</strong> Responsible for implementing specific code based on requirements, feature integration, bug fixing, UI adjustments, and documentation writing.</li>
</ul>
<h3 id="features">Features</h3>
<ul>
<li>  <strong>Broad Chip Support:</strong> Supports a wide range of classic FM synthesis chips, including YM2608, YM2151, YM2612, YM2203, YM2413, and more.</li>
<li>  <strong>Multi-Format Playback:</strong> Supports <code>.vgm</code>, <code>.vgz</code>, and <code>.s98</code> music file formats.</li>
<li>  <strong>Advanced Refresh Modes:</strong></li>
<li>  <strong>Flush Mode:</strong> Provides two data flush modes to control how frequently commands are sent to the SPFM hardware.</li>
<li>  <strong>Timer Mode:</strong> Offers multiple high-precision timing strategies for VGM playback to achieve the most accurate performance under various system loads.</li>
<li>  <strong>Built-in File Browser:</strong></li>
<li>  Press <code>F</code> to open the file browser, allowing you to easily switch between directories and select music files.</li>
<li>  <strong>Intuitive Player Interface:</strong></li>
<li>  Clearly displays the currently playing song, total duration, chip configuration, and various mode statuses.</li>
</ul>
<pre><code class="language- ```">    YASP - Yet Another Sound Player
    --------------------------------------------------
    Now Playing  : IF09_.vgm
    Total Time   : 01:28
    Slot 0: YM2608 | Slot 1: YM2151
    Flush Mode (1,2): Register-Level
    Timer Mode (3-0): VGMPlay-Optimized 1
    --------------------------------------------------
    [N] Next | [B] Prev | [P] Pause | [R] Random | [F] Browser | [+] Speed Up | [-] Speed Down | [Q] Quit
    --------------------------------------------------
    Status: Playing... | Random: Off | Speed: 1.00x
</code></pre>
<ul>
<li>  <strong>Easy-to-Use File Browser:</strong></li>
<li>  Features pagination and clear navigation to let you browse your music library with ease.</li>
</ul>
<pre><code class="language- ```">    File Browser
    --------------------------------------------------
    Current Dir: ./console_player/music/if-vgm
    Now Playing: ./console_player/music/if-vgm/IF14_.vgm
    --------------------------------------------------
    -&gt; ../
       IF01_.vgm
       IF02_.vgm
       IF03_.vgm
       IF04_.vgm
       IF05_.vgm
       IF06_.vgm
       IF07_.vgm
       IF08_.vgm
       IF09_.vgm
    --------------------------------------------------
    Page 1/2 | [Up/Down] Navigate | [Left/Right] Page | [Enter] Select | [F] Exit
</code></pre>
<ul>
<li>  <strong>Automatic Configuration Saving:</strong></li>
<li>  Settings such as chip selection, playback speed, and refresh modes are automatically saved to <code>config.ini</code> and loaded on the next launch.</li>
<li>  <strong>Real-time Playback Control:</strong> Supports next/previous track, pause/resume, random mode, and fine-tuning of playback speed during playback.</li>
<li>  <strong>Cross-Platform Design:</strong> Primarily designed for Windows, but the code structure is also compatible with POSIX-like systems (e.g., Linux).</li>
</ul>
<h3 id="flush-modes-explained">Flush Modes Explained</h3>
<p>The flush mode determines how frequently YASP sends commands to the SPFM hardware.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Mode</th>
<th>How It Works</th>
<th>Pros & Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1</code></td>
<td><strong>Register-Level</strong></td>
<td>Commands are continuously written to an internal buffer (<code>spfm_write_buf</code>). The <code>spfm_flush</code> function is only called to send the entire buffer over USB when the buffer is full or when a precise timing wait is encountered.</td>
<td><strong>Pro:</strong> Maximizes throughput. By merging multiple commands into a single USB transfer, it significantly reduces driver and hardware overhead, resulting in the highest performance.<br><strong>Con:</strong> Command transmission is not real-time, which may introduce microscopic latency.</td>
</tr>
<tr>
<td><code>2</code></td>
<td><strong>Command-Level</strong></td>
<td><strong>(Default)</strong> The <code>spfm_flush</code> function is called immediately after <strong>every</strong> command from the VGM file (like a register write or a short wait) is processed.</td>
<td><strong>Pro:</strong> Provides the most immediate response, ensuring each command is sent to the hardware with minimal delay.<br><strong>Con:</strong> USB transfers are very frequent, leading to higher driver overhead and theoretically lower performance than Register-Level mode.</td>
</tr>
</tbody>
</table>
<h3 id="timer-modes-explained-for-vgm-playback">Timer Modes Explained (for VGM Playback)</h3>
<p>YASP provides several advanced timer modes for VGM playback. The core idea is to <strong>no longer trust</strong> the operating system's <code>sleep</code> function, but instead to use the high-precision performance counter (<code>QueryPerformanceCounter</code>) to <strong>compensate for</strong> or <strong>drive</strong> the playback loop.</p>
<p><em>Note: These modes only affect <code>.vgm</code> and <code>.vgz</code> files. <code>.s98</code> files use their own hardware-based synchronization mechanism (the <code>0xFF</code> command) and are not affected by these settings.</em></p>
<h4 id="a-compensated-sleep-modes">A. Compensated Sleep Modes</h4>
<p>These modes share a common strategy: in a main loop, they first calculate the "time debt" (number of samples to process) based on real elapsed time, then "pay off" the debt by processing samples, and finally call a <code>sleep</code> function to yield the CPU. Even if the <code>sleep</code> is inaccurate, the next loop automatically compensates for the error.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Mode</th>
<th><code>g_timer_mode</code></th>
<th><code>sleep</code> Implementation</th>
<th>Recommended Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3</code></td>
<td><strong>H-Prec Compensated (Default)</strong></td>
<td>0</td>
<td>Uses <code>CreateWaitableTimer</code> (a high-precision kernel timer) for the <code>sleep</code>.</td>
<td><strong>General Recommendation</strong>. Low CPU usage, high precision. The best balance of stability and performance.</td>
</tr>
<tr>
<td><code>4</code></td>
<td><strong>Hybrid Compensated</strong></td>
<td>1</td>
<td>Uses a hybrid of <code>Sleep()</code> and busy-waiting (spin-wait) for the <code>sleep</code>.</td>
<td>An alternative option. May be more responsive on some systems than Mode 3, but with slightly higher CPU usage.</td>
</tr>
<tr>
<td><code>5</code></td>
<td><strong>MM-Timer Compensated</strong></td>
<td>2</td>
<td>Uses <code>timeSetEvent</code> (a multimedia timer) for the <code>sleep</code>.</td>
<td>An alternative option. Theoretically very precise, but the timer callback introduces some extra overhead.</td>
</tr>
</tbody>
</table>
<h4 id="b-event-driven-modes">B. Event-Driven Modes</h4>
<p>These modes do not rely on a <code>sleep</code> function. Instead, the playback loop is "awakened" by an external timer.</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Mode</th>
<th><code>g_timer_mode</code></th>
<th>How It Works</th>
<th>Recommended Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>6</code></td>
<td><strong>Classic VGMPlay</strong></td>
<td>3</td>
<td><strong>(Highly Recommended)</strong> The main loop is awakened by a 1ms high-precision multimedia timer (<code>timeSetEvent</code>). After each wakeup, it processes the appropriate number of samples based on real elapsed time. Because its pace is controlled by an external timer, it is theoretically more precise than compensated modes.</td>
<td>Very stable in most conditions and the gold standard for accurate playback.</td>
</tr>
<tr>
<td><code>7</code></td>
<td><strong>Optimized VGMPlay</strong></td>
<td>7</td>
<td><strong>(Most Stable)</strong> This is the <strong>"anti-runaway"</strong> version of Mode 6. It adds a "max samples per frame" limit (equivalent to 1/60th of a second) to the classic VGMPlay mode. This prevents the audio from suddenly "fast-forwarding" or stuttering after a system freeze.</td>
<td><strong>Highest Load Scenarios</strong>. Provides the smoothest experience when running CPU-intensive tasks in the background.</td>
</tr>
</tbody>
</table>
<h3 id="spfm-communication-protocol-explained">SPFM Communication Protocol Explained</h3>
<p>YASP communicates with the SPFM hardware via the FTDI D2XX driver. The core of the protocol is designed to efficiently send register writes and wait commands to the device.</p>
<h4 id="device-identification-and-handshake">Device Identification and Handshake</h4>
<p>During initialization, YASP attempts to identify the type of SPFM device.</p>
<ol>
<li> <strong>Handshake Signal</strong>: The program sends an <code>0xFF</code> byte to the device.</li>
<li> <strong>Device Response</strong>:</li>
</ol>
<ul>
<li>  <strong>SPFM Light</strong> devices respond with the string "LT".</li>
<li>  <strong>SPFM Standard</strong> devices respond with the string "OK".</li>
</ul>
<ol>
<li> <strong>Compatibility Mode</strong>: According to comments in the code, the current version of YASP <strong>bypasses</strong> this handshake process and defaults to identifying the device as <code>SPFM_TYPE_SPFM_LIGHT</code>. This is done to resolve compatibility issues on specific hardware where a strict handshake might fail, thus improving device compatibility.</li>
</ol>
<h4 id="command-format">Command Format</h4>
<p>The command format varies depending on the device type:</p>
<ul>
<li>  <strong>SPFM Light (4 bytes):</strong></li>
<li>  <code>{ slot, (port << 1), addr, data }</code></li>
<li>  <code>slot</code>: The chip's slot (0 or 1).</li>
<li>  <code>port</code>: The chip's port.</li>
<li>  <code>addr</code>: The register address to write to.</li>
<li>  <code>data</code>: The data to be written.</li>
</ul>
<ul>
<li>  <strong>SPFM Standard (3 bytes):</strong></li>
</ul>
<ul>
<li>  <code>{ (slot << 4) | port, addr, data }</code></li>
<li>  <code>slot</code>: The chip's slot (0-7).</li>
<li>  <code>port</code>: The chip's port (0-3).</li>
<li>  <code>addr</code>: The register address to write to.</li>
<li>  <code>data</code>: The data to be written.</li>
</ul>
<p><em>Note: The current version of YASP defaults to SPFM Light mode for compatibility reasons.</em></p>
<h4 id="write-buffering-mechanism">Write Buffering Mechanism</h4>
<p>To maximize throughput and reduce the overhead of FTDI driver calls, YASP implements a write buffer (<code>spfm_write_buf</code>).</p>
<ol>
<li> When functions like <code>spfm_write_reg</code> are called, the command data is <strong>not</strong> sent immediately. Instead, it is staged in this buffer.</li>
<li> The <code>spfm_flush</code> function is only called when the buffer is full or when a precise timing operation (like a sleep) is required.</li>
<li> <code>spfm_flush</code> sends the entire buffer's content in a single <code>FT_Write</code> call to the SPFM device, significantly improving efficiency.</li>
</ol>
<h4 id="hardware-vs-software-waits">Hardware vs. Software Waits</h4>
<p>YASP employs a hybrid waiting strategy to balance precision and CPU usage:</p>
<ul>
<li>  <strong>Hardware Wait:</strong></li>
<li>  When the device is <code>SPFM_Light</code> and the wait duration is extremely short (less than 10 audio samples), YASP sends an <code>0x80</code> command.</li>
<li>  This command is handled by the SPFM hardware itself, enabling a highly precise, near-zero CPU-cost wait.</li>
<li>  <strong>Software Wait:</strong></li>
<li>  For longer waits, or on devices that do not support hardware waits, YASP calls the <code>yasp_usleep</code> function.</li>
<li>  This function executes a high-precision software wait based on the user-selected timer mode (e.g., High-Precision Sleep, Multimedia Timer).</li>
</ul>
<p>This design makes YASP highly efficient at processing the numerous short wait commands found in VGM/S98 files, while also yielding the CPU during longer waits to avoid wasting resources.</p>
<h3 id="controls">Controls</h3>
<h4 id="player-interface">Player Interface</h4>
<table>
<thead>
<tr>
<th>Key</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>q</code></td>
<td>Quit the player</td>
</tr>
<tr>
<td><code>p</code></td>
<td>Pause/Resume playback</td>
</tr>
<tr>
<td><code>n</code></td>
<td>Next track</td>
</tr>
<tr>
<td><code>b</code></td>
<td>Previous track</td>
</tr>
<tr>
<td><code>r</code></td>
<td>Toggle random mode</td>
</tr>
<tr>
<td><code>f</code></td>
<td>Open file browser</td>
</tr>
<tr>
<td><code>+</code></td>
<td>Increase playback speed (by 0.01)</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Decrease playback speed (by 0.01)</td>
</tr>
<tr>
<td><code>1</code></td>
<td>Switch to <code>Register-Level</code> flush mode</td>
</tr>
<tr>
<td><code>2</code></td>
<td>Switch to <code>Command-Level</code> flush mode (Default)</td>
</tr>
<tr>
<td><code>3</code>-<code>7</code></td>
<td>Switch between different VGM timer modes (see previous section)</td>
</tr>
</tbody>
</table>
<h4 id="file-browser-interface">File Browser Interface</h4>
<table>
<thead>
<tr>
<th>Key</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Up</code> / <code>Down</code> Arrow</td>
<td>Navigate up/down</td>
</tr>
<tr>
<td><code>Left</code> / <code>Right</code> Arrow</td>
<td>Page up/down</td>
</tr>
<tr>
<td><code>Enter</code></td>
<td>Enter a directory or select a file to play</td>
</tr>
<tr>
<td><code>Backspace</code></td>
<td>Go to the parent directory</td>
</tr>
<tr>
<td><code>f</code></td>
<td>Exit the browser and return to the player</td>
</tr>
</tbody>
</table>
<h3 id="build-instructions">Build Instructions</h3>
<h4 id="windows-using-mingw-msys2">Windows (using MinGW/MSYS2)</h4>
<ol>
<li> Ensure you have MinGW-w64 or MSYS2 installed and its <code>bin</code> directory added to your system PATH.</li>
<li> Place the FTDI D2XX driver files (<code>ftd2xx.h</code>, <code>ftd2xx.lib</code> or <code>libftd2xx.a</code>) in the <code>ftdi_driver</code> folder in the project root.</li>
<li> Open a command line, navigate to the <code>console_player</code> directory.</li>
<li> Run the <code>make</code> command to compile:</li>
</ol>
<pre><code class="language- ```bash">    make -C console_player
</code></pre>
<ol>
<li> Upon successful compilation, <code>yasp_test.exe</code> will be generated in the <code>console_player</code> directory.</li>
</ol>
<h4 id="linux-macos">Linux / macOS</h4>
<p>The build process is similar to Windows, but you need to ensure the <code>libftdi</code> development library is installed. The <code>makefile</code> will automatically handle platform-specific linking options.</p>
<h3 id="source-code-references">Source Code References</h3>
<p>This C language version of the player heavily referenced the following projects:</p>
<ul>
<li>  <strong><code>node-spfm</code></strong> (developed by Denjhang):</li>
<li>  <strong>Location</strong>: <code>D:\working\vscode-projects\yasp11\node-spfm-denjhang-main</code></li>
<li>  <strong>Contribution</strong>: A full-featured Node.js implementation that provided the core logic and algorithmic foundation for this C port, especially in the areas of SPFM communication protocol, VGM/S98 file parsing, and chip control logic.</li>
</ul>
<ul>
<li>  <strong>VGMPlay</strong> (developed by Valley Bell):</li>
<li>  <strong>Contribution</strong>: In the project's early stages, the traditional <code>sleep</code>-based timing method caused unstable playback speeds during high CPU load operations like window switching or file decompression. To solve this, the project adopted and implemented VGMPlay's core timing model. This model does not rely on fixed <code>sleep</code> intervals but instead dynamically calculates the number of audio samples to process based on the real elapsed time (<code>QueryPerformanceCounter</code>), fundamentally ensuring stable and accurate playback under various system loads.</li>
</ul>
<h4 id="key-referenced-areas">Key Referenced Areas:</h4>
<ul>
<li>  <strong>SPFM Communication Protocol:</strong></li>
</ul>
<p>    The logic for handshaking, sending commands, and data to the SPFM hardware, as defined in <code>node-spfm/src/spfm.ts</code>, served as the foundation for the implementation in <code>console_player/spfm.c</code>. This includes key operations like device initialization, chip reset, and register writing.</p>
<ul>
<li>  <strong>VGM File Parsing:</strong></li>
</ul>
<p>    The logic for parsing VGM file headers, processing data blocks, and interpreting commands from <code>node-spfm/src/vgm.ts</code> was directly adapted and re-implemented in C in <code>console_player/vgm.c</code>. This ensured accurate support for the VGM format.</p>
<ul>
<li>  <strong>Chip Control Logic:</strong></li>
</ul>
<p>    The control classes for different FM chips (e.g., YM2151, YM2608) in the <code>node-spfm/src/chips/</code> directory provided accurate references for register addresses and control commands in our project's files like <code>console_player/ym2151.c</code> and <code>console_player/ym2608.c</code>.</p>
<p>In addition to <code>node-spfm</code>, the project involved modifications and implementations in the following files:</p>
<ul>
<li>  <code>console_player/main.c</code>: The main program entry point, responsible for initialization, configuration loading, the playback loop, and keyboard input handling.</li>
<li>  <code>console_player/play.c</code>: Core of the player's UI display and file playback logic.</li>
<li>  <code>console_player/util.c</code> & <code>console_player/util.h</code>: Implementation of various timer modes and utility functions.</li>
<li>  <code>console_player/makefile</code>: The project's build script, responsible for compiling and linking all source files.</li>
</ul>

<script>
    window.onscroll = function() {
        updateProgressBar();
    };

    document.getElementById("progress-container").onclick = function(event) {
        var rect = this.getBoundingClientRect();
        var clickX = event.clientX - rect.left;
        var percentage = clickX / this.offsetWidth;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        window.scrollTo(0, height * percentage);
    };

    function updateProgressBar() {
        var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        var scrolled = (winScroll / height) * 100;
        document.getElementById("progress-bar").style.width = scrolled + "%";
    }
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YASP - Yet Another Sound Player (技术文档)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            padding-bottom: 50px; /* Add padding to prevent content from being hidden by the progress bar */
        }
        #progress-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 8px;
            background-color: #f0f0f0;
            z-index: 1000;
            cursor: pointer;
        }
        #progress-bar {
            height: 100%;
            width: 0;
            background-color: #0366d6;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h3 { font-size: 1.25em; }
        h4 { font-size: 1em; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        code {
            padding: .2em .4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 3px;
        }
        pre code {
            display: inline;
            padding: 0;
            margin: 0;
            overflow: visible;
            line-height: inherit;
            word-wrap: normal;
            background-color: transparent;
            border: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1em;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid #dfe2e5;
            padding: 6px 13px;
        }
        th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        ul, ol { padding-left: 2em; }
        li { margin-top: .25em; }

        /* Hierarchical TOC styles */
        .toc-level-1 { font-weight: 500; }
        .toc-level-2 { margin-left: 1.5em; }
        .toc-level-3 { margin-left: 3em; }
        .toc-level-4 { margin-left: 4.5em; }
        .toc-level-1 > a { font-size: 1.1em; }
        .toc-level-2 > a { font-size: 1.0em; }
        .toc-level-3 > a { font-size: 0.95em; }
        .toc-level-4 > a { font-size: 0.9em; color: #333; }

        blockquote {
            margin-left: 0;
            padding-left: 1em;
            color: #6a737d;
            border-left: .25em solid #dfe2e5;
        }
    </style>
</head>
<body>
<div id="progress-container">
    <div id="progress-bar"></div>
</div>
<h1 id="yasp-yet-another-sound-player">YASP - Yet Another Sound Player (技术文档)</h1>
<h2 id="">摘要</h2>
<p>YASP (Yet Another Sound Player) 作为一款纯 C 语言编写的、专为 SPFM (Sound-Processing FM-synthesis) 系列硬件设计的、功能强大的命令行音乐播放器，它专注于高效、精确地播放经典的 VGM 和 S98 格式音乐文件。本文档旨在深入剖析其核心技术实现，包括高级计时系统、SPFM 通信协议、以及创新的芯片转换与缓存机制。</p>
<hr>
<h2 id="table-of-contents">目录</h2>
<ol>
<li> <a href="#1-源码参考与致谢">源码参考与致谢</a></li>
<li> <a href="#2-项目背景与架构">项目背景与架构</a></li>
<li> <a href="#3-c-语言核心实践与代码风格">C 语言核心实践与代码风格</a></li>
<li> <a href="#4-核心功能与特色">核心功能与特色</a></li>
<li> <a href="#5-关键技术剖析">关键技术剖析</a></li>
</ol>
<ul>
<li class="toc-level-2">  <a href="#51-vgm-文件处理流程">5.1. VGM 文件处理流程</a></li>
<li class="toc-level-2">  <a href="#52-智能芯片转换">5.2. 智能芯片转换</a></li>
<li class="toc-level-2">  <a href="#53-高级计时与刷新系统">5.3. 高级计时与刷新系统</a></li>
<li class="toc-level-2">  <a href="#54-spfm-通信协议">5.4. SPFM 通信协议</a></li>
</ul>
<ol>
<li> <a href="#6-操作指南">操作指南</a></li>
<li> <a href="#7-编译与构建">编译与构建</a></li>
</ol>
<hr>
<h2 id="1">1. 源码参考与致谢</h2>
<p>YASP 的开发深度参考了以下优秀项目，在此对这些项目的作者表示由衷的敬意和感谢。他们的工作为 YASP 的实现提供了坚实的基础和关键的灵感。</p>
<ul>
<li>  <strong><code>yasp (Yet Another SPFM Light Player)</code></strong></li>
<li>  <strong>作者</strong>: uobikiemukot</li>
<li>  <strong>贡献</strong>: <strong>本项目的起点和最初的灵感来源。</strong> YASP 的名称继承自此项目，其早期的代码结构为本项目的开发提供了宝贵的初始框架和方向。</li>
</ul>
<ul>
<li>  <strong><code>node-spfm</code></strong></li>
<li>  <strong>作者</strong>: Mitsutaka Okazaki (digital-sound-antiques), Denjhang</li>
<li>  <strong>贡献</strong>: 提供了本项目的核心逻辑和算法基础，特别是在 SPFM 通信协议 (<code>spfm.c</code>)、芯片控制以及 OPN 到 OPM 的转换算法 (<code>opn_to_opm.c</code>) 方面。</li>
</ul>
<ul>
<li>  <strong>VGMPlay</strong></li>
<li>  <strong>作者</strong>: Valley Bell</li>
<li>  <strong>贡献</strong>: 本项目的高级计时系统 (<code>util.c</code> 中的 <code>yasp_usleep</code>) 完全基于 VGMPlay 的核心计时模型，从根本上解决了播放稳定性的问题。模式 6 (VGMPlay Mode) 和模式 7 (Optimized VGMPlay Mode) 直接来源于其思想。</li>
</ul>
<ul>
<li>  <strong><code>vgm-conv</code></strong></li>
<li>  <strong>作者</strong>: Mitsutaka Okazaki (digital-sound-antiques)</li>
<li>  <strong>贡献</strong>: 芯片频率转换的精确数学模型来源于此项目。</li>
</ul>
<ul>
<li>  <strong><code>vgm-parser-js</code></strong></li>
<li>  <strong>作者</strong>: Mitsutaka Okazaki (digital-sound-antiques)</li>
<li>  <strong>贡献</strong>: 在解决 GD3 标签缓存问题时，本项目借鉴了其 <code>vgm-parser-main</code> 模块中健壮的“完整文件载入内存”处理策略 (<code>vgm.c</code>)，为最终的成功实现提供了关键思路。</li>
</ul>
<h2 id="2">2. 项目背景与架构</h2>
<p>YASP 旨在为 SPFM 硬件爱好者提供一个功能强大且高度可定制的命令行音乐播放器。项目由 <strong>Denjhang</strong> (项目所有者/主要开发者) 和 <strong>Cline</strong> (AI 软件工程师) 合作完成，前者负责需求、架构和关键技术验证，后者负责具体实现、集成和文档撰写。</p>
<p><strong>核心架构:</strong></p>
<ul>
<li>  <code>main.c</code>: 主程序入口，负责初始化、配置加载、主播放循环和键盘输入处理。</li>
<li>  <code>play.c</code>: 播放器 UI 渲染和状态管理的核心。</li>
<li>  <code>vgm.c</code> / <code>s98.c</code>: 分别负责 VGM 和 S98 文件的解析、命令处理和播放逻辑。</li>
<li>  <code>opn_to_opm.c</code>, <code>ay_to_opm.c</code>, <code>sn_to_ay.c</code>: 实现芯片指令转换的模块。</li>
<li>  <code>util.c</code>: 包含高精度定时器、<code>yasp_usleep</code> 实现和 <code>ini</code> 文件读写等辅助工具。</li>
<li>  <code>spfm.c</code>: 封装了与 SPFM 硬件通过 FTDI D2XX 驱动进行通信的底层逻辑。</li>
</ul>
<h2 id="3">3. C 语言核心实践与代码风格</h2>
<p>本项目完全采用<strong>纯 C 语言</strong>编写，充分利用了 C 语言在系统级编程中的性能优势和对内存的精确控制能力。代码风格体现了 C 语言的典型范式，特别是在<strong>结构体 (struct)</strong>、<strong>指针 (pointer)</strong> 和 <strong>函数指针 (function pointer)</strong> 的大量使用上。</p>
<h3 id="3-1">3.1. 使用结构体封装复杂数据</h3>
<p>结构体是本项目组织数据的核心。例如，<code>vgm.h</code> 中定义的 <code>vgm_header_t</code> 结构体，将一个 VGM 文件的所有元数据（如版本、时钟频率、循环点、GD3 标签等）封装成一个逻辑清晰的单元。</p>
<pre><code class="language-c">// in vgm.h
typedef struct {
    uint8_t ident[4];
    uint32_t eof_offset;
    uint32_t version;
    uint32_t sn76489_clock;
    uint32_t ym2413_clock;
    uint32_t gd3_offset;
    uint32_t total_samples;
    uint32_t loop_offset;
    uint32_t loop_samples;
    // ... more fields
    wchar_t track_name_en[256];
    wchar_t track_name_jp[256];
    // ... more GD3 tag fields
} vgm_header_t;
</code></pre>
<p><strong>解说</strong>: 这种做法使得复杂的数据可以作为一个整体在函数间传递，极大地提高了代码的可读性和可维护性。通过一个指向 <code>vgm_header_t</code> 的指针，函数可以访问和修改文件的所有元数据，而无需传递几十个独立的参数。</p>
<h3 id="3-2">3.2. 通过函数指针实现回调与解耦</h3>
<p>函数指针是实现回调机制和模块解耦的关键。一个典型的例子是芯片转换模块的初始化函数，它接收一个“写入器” (writer) 函数作为参数。</p>
<pre><code class="language-c">// in opn_to_opm.c
// 定义一个静态的函数指针变量，用于存储回调函数
static void (*_writer)(uint8_t addr, uint8_t data);

// 初始化函数，接收一个函数指针作为参数
void opn_to_opm_init(chip_type_t type, uint32_t clock, void (*writer)(uint8_t, uint8_t)) {
    // ...
    _writer = writer; // 将传入的函数指针存储起来
}

// 在需要写入数据时，调用这个存储的函数指针
static void _y(uint8_t addr, uint8_t data) {
    if (_writer) {
        _writer(addr, data);
    }
}
</code></pre>
<p><strong>解说</strong>: <code>opn_to_opm_init</code> 并不知道数据最终会被写入到哪里——是直接发送到 SPFM 硬件，还是写入一个缓存文件。它只关心调用 <code>_writer</code> 函数。这种设计将<strong>数据转换逻辑</strong>与<strong>数据写入目标</strong>完全解耦。在 <code>vgm.c</code> 中，我们可以根据需要，向它传递不同的写入函数（<code>spfm_opm_writer</code> 或 <code>vgm_cache_opm_writer</code>），从而实现了极高的灵活性。</p>
<h3 id="3-3">3.3. 指针与内存的精确控制</h3>
<p>作为一款性能敏感的播放器，本项目大量使用指针直接操作内存，以实现最高效率。VGM 文件缓存的实现是最好的例子。</p>
<pre><code class="language-c">// in vgm.c&apos;s vgm_play function
// 1. 分配内存
fseek(input_fp, 0, SEEK_END);
long original_file_size = ftell(input_fp);
fseek(input_fp, 0, SEEK_SET);
uint8_t* original_file_data = malloc(original_file_size);

// 2. 将文件完整读入内存
fread(original_file_data, 1, original_file_size, input_fp);
fclose(input_fp); // 立即关闭文件

// 3. 直接通过指针从内存中读取和写入数据
uint32_t gd3_offset_in_header = read_le32(original_file_data + 0x14);
// ...
fwrite(original_file_data + gd3_abs_offset, 1, total_gd3_size, g_cache_fp);

// 4. 释放内存
free(original_file_data);
</code></pre>
<p><strong>解说</strong>: 这种对 <code>malloc</code>、<code>free</code> 和指针算术（如 <code>original_file_data + 0x14</code>）的直接使用，是典型的 C 语言风格。它避免了高级语言中可能存在的额外开销，将文件 I/O 操作减到最少，并将所有处理都放在速度最快的内存中进行，这是实现高性能缓存和无损 GD3 标签处理的根本。</p>
<h2 id="4">4. 核心功能与特色</h2>
<ul>
<li>  <strong>广泛的芯片支持:</strong> YASP 支持多种经典的音源芯片，无论是直接播放还是通过自动转换，覆盖了大量怀旧游戏音乐的需求。支持的芯片列表如下：</li>
<li>  YM2608, YM2151, YM2612, YM2203, YM2413, YM3526, YM3812, Y8950, AY8910, SN76489, YMF262, SEGAPCM, RF5C68, YM2610</li>
<li>  <strong>多格式播放:</strong> 支持 <code>.vgm</code>, <code>.vgz</code>, 和 <code>.s98</code> 音乐文件。</li>
<li>  <strong>GD3 标签保真:</strong> 采用先进的内存处理技术，确保在转换和缓存过程中，VGM 文件内的 GD3 音乐标签被完整保留。</li>
<li>  <strong>高级计时系统:</strong> 提供多种基于高精度性能计数器的计时策略，确保在各种系统负载下都能实现精确、无抖动的音频播放。</li>
<li>  <strong>内置文件浏览器:</strong> 方便用户在文件系统中导航和选择音乐。</li>
</ul>
<h2 id="5">5. 关键技术剖析</h2>
<h3 id="5-1">5.1. VGM 文件处理流程</h3>
<p>为了解决在文件转换和缓存过程中遇到的数据一致性问题（特别是 GD3 标签的丢失），YASP 采用了一种健壮的、基于内存的处理流程。该机制的核心是：在需要创建缓存时，<strong>先将整个原始 VGM 文件一次性完整读入内存</strong>，然后关闭文件句柄。后续的转换、GD3 标签提取和新缓存文件的写入，都基于这个内存副本进行操作。这种“先完整载入，再隔离处理”的策略，确保了数据源的唯一性和不可变性，是保证播放流畅、转换无误和 GD3 标签不丢失的基石。</p>
<p>以下是 <code>vgm.c</code> 中 <code>vgm_play</code> 函数实现此流程的关键代码：</p>
<p><strong>1. 将整个原始 VGM 文件读入内存</strong></p>
<pre><code class="language-c">// 1. Read entire original file into memory
fseek(input_fp, 0, SEEK_END);
long original_file_size = ftell(input_fp);
fseek(input_fp, 0, SEEK_SET);
uint8_t* original_file_data = malloc(original_file_size);
if (!original_file_data || fread(original_file_data, 1, original_file_size, input_fp) != original_file_size) {
    logging(LOG_ERROR, &quot;Failed to read original VGM file into memory.&quot;);
    if (original_file_data) free(original_file_data);
    return;
}
fclose(input_fp); // Close original file, we have it in memory now
</code></pre>
<p><strong>解说</strong>: 这是“先完整载入”策略的直接体现。代码获取文件大小，分配等大的内存，然后一次性将整个文件读入 <code>original_file_data</code> 缓冲区。完成后，立即关闭原始文件句柄，后续所有操作都与磁盘上的原始文件无关，从根本上避免了文件指针混乱的问题。</p>
<p><strong>2. 从内存中提取 GD3 标签并写入缓存</strong></p>
<pre><code class="language-c">// 4. Write GD3 block from memory to cache
long gd3_start_in_cache = 0;
uint32_t gd3_offset_in_header = read_le32(original_file_data + 0x14);
if (gd3_offset_in_header &gt; 0) {
    uint32_t gd3_abs_offset = 0x14 + gd3_offset_in_header;
    uint32_t gd3_length = read_le32(original_file_data + gd3_abs_offset + 8);
    uint32_t total_gd3_size = 12 + gd3_length;
    
    gd3_start_in_cache = ftell(g_cache_fp);
    fwrite(original_file_data + gd3_abs_offset, 1, total_gd3_size, g_cache_fp);
}
</code></pre>
<p><strong>解说</strong>: 这是“隔离处理”策略的关键一步。代码直接从内存缓冲区 <code>original_file_data</code> 中读取 GD3 标签的偏移和长度，然后将完整的 GD3 数据块（包括头部和内容）原封不动地写入新的缓存文件。这确保了 GD3 信息的无损迁移。</p>
<p><strong>3. 从内存中进行数据转换</strong></p>
<pre><code class="language-c">// In vgm_play:
const uint8_t* vgm_data_ptr = original_file_data + g_vgm_header.vgm_data_offset;
size_t vgm_data_size = (g_vgm_header.eof_offset + 4) - g_vgm_header.vgm_data_offset;
vgm_convert_and_cache_opn_to_opm_from_mem(vgm_data_ptr, vgm_data_size, &amp;g_vgm_header);

// The conversion function itself:
static bool vgm_convert_and_cache_opn_to_opm_from_mem(const uint8_t* vgm_data, size_t vgm_data_size, const vgm_header_t* original_header) {
    // ... loop through vgm_data (memory buffer) and convert ...
}
</code></pre>
<p><strong>解说</strong>: 转换函数 <code>vgm_convert_and_cache_opn_to_opm_from_mem</code> 的输入不再是文件指针，而是指向内存中 VGM 数据部分的指针 <code>vgm_data</code>。这彻底避免了在文件流上进行读写操作可能引发的数据不一致问题，保证了转换过程的纯粹和可靠。</p>
<h3 id="5-2">5.2. 智能芯片转换</h3>
<p>当检测到用户硬件上缺少 VGM 文件所需的芯片，但存在可替代的目标芯片时，YASP 会自动执行转换。</p>
<h4 id="5-2-1">5.2.1. 转换路径概览</h4>
<table>
<thead>
<tr>
<th>源芯片 (Source)</th>
<th>目标芯片 (Target)</th>
<th>转换模块</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>YM2612/2203/2608 (OPN)</strong></td>
<td>YM2151 (OPM)</td>
<td><code>opn_to_opm.c</code></td>
<td>核心 FM 音源转换，支持频率、包络等参数映射。</td>
</tr>
<tr>
<td><strong>AY8910 (PSG)</strong></td>
<td>YM2151 (OPM)</td>
<td><code>ay_to_opm.c</code></td>
<td>使用 OPM 的 FM 合成来模拟 PSG 的方波和噪声。</td>
</tr>
<tr>
<td><strong>SN76489 (DCSG)</strong></td>
<td>AY8910 (PSG)</td>
<td><code>sn_to_ay.c</code></td>
<td>中间步骤，将 SN76489 指令转为 AY8910 指令。</td>
</tr>
<tr>
<td><strong>SN76489 (DCSG)</strong></td>
<td>YM2151 (OPM)</td>
<td><code>sn_to_ay.c</code> -> <code>ay_to_opm.c</code></td>
<td><strong>转换链</strong>：SN76489 -> AY8910 -> YM2151。</td>
</tr>
</tbody>
</table>
<h4 id="5-2-2">5.2.2. 核心转换源码详解</h4>
<p><strong>1. OPN (YM2612/2203/2608) -> OPM (YM2151)</strong></p>
<p>这是最核心的 FM 音源转换。主要在 <code>opn_to_opm.c</code> 中实现。OPN 系列使用 <code>F-Number</code> 和 <code>Block</code> 定义频率，而 OPM 使用 <code>Key Code</code> 和 <code>Key Fraction</code>。转换必须通过以下数学公式完成：</p>
<pre><code class="language-c">// 1. OPN 参数转为实际频率 (Hz)
double freq = (_source_clock * fnum) / ((72.0 * _clock_div) * (1 &lt;&lt; (20 - blk)));

// 2. 频率转为 OPM 的音高值 (Key)
const double BASE_FREQ_OPM = 277.2; // OPM 基准频率
double key = 60.0 + log2((freq * _clock_ratio) / BASE_FREQ_OPM) * 12.0;

// 3. Key 值拆分为 Key Code (KC) 和 Key Fraction (KF)
*kc = (oct &lt;&lt; 4) | note;
*kf = (uint8_t)floor(frac * 64.0);
</code></pre>
<p>这段代码精确地将一个音源的频率体系映射到了另一个完全不同的体系上。</p>
<p><strong>2. AY8910 (PSG) -> OPM (YM2151)</strong></p>
<p>此转换在 <code>ay_to_opm.c</code> 中实现，目标是用 OPM 的 FM 合成来<strong>模拟</strong> PSG 的方波和噪声。OPM 本身没有方波通道，因此代码使用了一个特殊的 FM 音色（<code>CON=4</code>）来模拟方波。</p>
<pre><code class="language-c">// 在 ay_to_opm_init 中，为 OPM 通道 4,5,6 设置模拟方波的音色
_y(0x20 + opmCh, 0xfc); // RL=ON FB=7 CON=4
_y(0x60 + opmCh, 0x1b); // M1: TL=27 (设置一个基础音量)
_y(0x80 + opmCh, 0x1f); // M1: AR=31 (快速起音)
</code></pre>
<p>同时，PSG 的对数式音量需要通过查找表 <code>VOL_TO_TL</code> 转换为 OPM 的线性 <code>Total Level</code> (TL)。</p>
<pre><code class="language-c">// VOL_TO_TL 数组
static const int VOL_TO_TL[] = {127, 62, 56, 52, 46, 42, 36, 32, 28, 24, 20, 16, 12, 8, 4, 0};

// 在 _updateTone 函数中应用
const int tVol = (v &amp; 0x10) ? 0 : (v &amp; 0xf); // 获取音量值
_y(0x70 + opmCh, fmin(127, VOL_TO_TL[tVol &amp; 0xf])); // 查表并写入 OPM 的 TL 寄存器
</code></pre>
<p><strong>3. SN76489 (DCSG) -> AY8910 (PSG)</strong></p>
<p>这是一个中间转换步骤，在 <code>sn_to_ay.c</code> 中实现。其核心是处理 SN76489 的通道3与噪声的混合逻辑，因为这与 AY8910 的行为不同。</p>
<pre><code class="language-c">// 在 _updateSharedChannel 函数中处理混合逻辑
static void _updateSharedChannel() {
    int noiseChannel = _mixChannel; // 通常是通道 2
    bool enableTone = _atts[noiseChannel] != 0xf;
    bool enableNoise = _atts[3] != 0xf;

    // 混合解析：如果噪声和音调都启用，噪声优先
    if (enableTone &amp;&amp; enableNoise) {
        enableTone = false;
    }
    
    // 根据解析结果，设置 AY8910 的通道和噪声使能寄存器 (R7)
    const uint8_t toneMask = enableTone ? 0 : (1 &lt;&lt; noiseChannel);
    const uint8_t noiseMask = enableNoise ? (7 &amp; ~(1 &lt;&lt; noiseChannel)) : 7;
    _y(7, (noiseMask &lt;&lt; 3) | toneMask); // _y() 会调用 ay_to_opm_write_reg()
}
</code></pre>
<p>这段代码是整个转换链能够正确发声的关键。</p>
<h3 id="5-3">5.3. 高级计时与刷新系统</h3>
<p>YASP 的播放精度和稳定性由“刷新模式”和“定时器模式”共同决定。</p>
<h4 id="5-3-1">5.3.1. 刷新模式 (Flush Mode)</h4>
<p>刷新模式决定了播放器将寄存器数据发送到 SPFM 硬件的<strong>粒度</strong>。</p>
<table>
<thead>
<tr>
<th>模式 (按键)</th>
<th>名称</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>寄存器级 (Register-Level)</td>
<td><strong>每一次</strong>寄存器写入后，立刻调用 <code>spfm_flush()</code>。这保证了最高的实时性，但 USB 通信开销巨大。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><strong>命令级 (Command-Level)</strong></td>
<td>仅在处理完一个完整的 VGM 命令后（如 <code>0x61 nn nn</code> 这样的等待命令，或一个芯片写入命令），才调用 <code>spfm_flush()</code>。这是<strong>性能和实时性的最佳平衡</strong>，也是默认设置。</td>
</tr>
</tbody>
</table>
<h4 id="5-3-2">5.3.2. 定时器模式 (Timer Mode)</h4>
<p>定时器模式决定了播放器在处理完 VGM 命令后，如何精确地<strong>等待</strong>到下一个事件发生。所有模式都基于高精度性能计数器 (<code>QueryPerformanceCounter</code>) 进行误差补偿。</p>
<table>
<thead>
<tr>
<th>模式 (按键)</th>
<th>源码名称</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>3</strong></td>
<td>High-Precision Sleep</td>
<td>调用 <code>Sleep(1)</code> 等待，并用性能计数器补偿其巨大的不精确性。适用于低负载环境。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Hybrid Sleep</td>
<td>使用 <code>CreateWaitableTimer</code> 等待 1ms，并补偿误差。比 <code>Sleep(1)</code> 更精确。</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>Multimedia Timer</td>
<td>使用 <code>timeSetEvent</code> 设置一个 1ms 的高精度多媒体定时器。播放线程等待该定时器触发的事件。精度高，但高负载下事件可能延迟。</td>
</tr>
<tr>
<td><strong>6</strong></td>
<td><strong>VGMPlay Mode</strong></td>
<td>“忙等”的变体，不断调用 <code>Sleep(0)</code> 让出时间片，响应极快，但 CPU 占用率极高。</td>
</tr>
<tr>
<td><strong>7</strong></td>
<td><strong>Optimized VGMPlay Mode</strong></td>
<td>模式 5 的优化版，增加了“防失控”机制，防止声音滞后和崩溃。<strong>这是默认和最佳选择。</strong></td>
</tr>
</tbody>
</table>
<h4 id="5-3-3">5.3.3. 定时器核心源码详解</h4>
<p>以下是 <code>util.c</code> 中 <code>yasp_usleep</code> 函数针对不同模式的核心实现：</p>
<p><strong>模式 3: High-Precision Sleep</strong></p>
<pre><code class="language-c">case 0: // High-Precision Sleep
    tick_to_wait = get_tick() + us_to_tick(us);
    while (get_tick() &lt; tick_to_wait) {
        Sleep(1);
    }
    break;
</code></pre>
<p><strong>解说</strong>: 这是最简单的实现。循环调用 <code>Sleep(1)</code>，每次让出至少 1ms 的时间片，直到性能计数器达到目标时间。<code>Sleep</code> 的精度很差，但 CPU 占用率低。</p>
<p><strong>模式 4: Hybrid Sleep</strong></p>
<pre><code class="language-c">case 1: // Hybrid Sleep
    tick_to_wait = get_tick() + us_to_tick(us);
    while (get_tick() &lt; tick_to_wait) {
        WaitForSingleObject(g_waitable_timer, 1);
    }
    break;
</code></pre>
<p><strong>解说</strong>: 使用 Windows 的可等待定时器 <code>WaitForSingleObject</code> 等待 1ms。它比 <code>Sleep(1)</code> 更精确，是精度和 CPU 占用的一个折中。</p>
<p><strong>模式 5: Multimedia Timer</strong></p>
<pre><code class="language-c">case 2: // Multimedia Timer
    tick_to_wait = get_tick() + us_to_tick(us);
    while (get_tick() &lt; tick_to_wait) {
        WaitForSingleObject(g_timer_event, 1);
    }
    break;
</code></pre>
<p><strong>解说</strong>: 依赖于一个由 <code>timeSetEvent</code> 创建的、在后台每 1ms 触发一次的 <code>g_timer_event</code> 事件。线程等待这个事件，精度很高。</p>
<p><strong>模式 6: VGMPlay Mode</strong></p>
<pre><code class="language-c">case 3: // VGMPlay Mode
    tick_to_wait = get_tick() + us_to_tick(us);
    while (get_tick() &lt; tick_to_wait) {
        Sleep(0);
    }
    break;
</code></pre>
<p><strong>解说</strong>: 这是“忙等”的一种形式。<code>Sleep(0)</code> 会让当前线程立即放弃剩余的时间片，让其他线程运行。这使得循环检测时间的频率非常高，响应极快，但会持续占用 CPU。</p>
<p><strong>模式 7: Optimized VGMPlay Mode</strong></p>
<p>此模式的优化不在 <code>yasp_usleep</code> 中，而在 <code>play.c</code> 的 <code>vgm_play</code> 函数里。它使用与模式 5 相同的等待机制，但增加了“防失控”逻辑：</p>
<pre><code class="language-c">// 在 play.c 的 vgm_play 中
if (g_timer_mode == 7) {
    vgm_slice_to_do = min(vgm_slice_to_do, g_vgm_slice_limiter);
}
</code></pre>
<p><strong>解说</strong>: 如果因为系统繁忙导致定时器事件严重延迟，积压了大量需要播放的样本 (<code>vgm_slice_to_do</code>)，此代码会将其限制在一个最大值 (<code>g_vgm_slice_limiter</code>) 内。这可以防止声音出现长时间的滞后，并快速追上实时进度，代价是丢弃少量积压的样本。</p>
<h3 id="5-4">5.4. SPFM 通信协议</h3>
<p>YASP 通过 FTDI D2XX 驱动与 SPFM 硬件通信。其核心是<strong>写入缓冲机制</strong>和<strong>混合等待策略</strong>。对于极短的等待（<10个样本），发送硬件等待命令 <code>0x80</code>；对于较长的等待，则调用由上述定时器模式决定的高精度软件等待函数 <code>yasp_usleep</code>。</p>
<h2 id="6">6. 操作指南</h2>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>p</code></td>
<td>暂停/继续</td>
</tr>
<tr>
<td><code>n</code> / <code>b</code></td>
<td>下一首 / 上一首</td>
</tr>
<tr>
<td><code>r</code></td>
<td>切换随机/顺序播放</td>
</tr>
<tr>
<td><code>f</code></td>
<td>打开/关闭文件浏览器</td>
</tr>
<tr>
<td><code>+</code> / <code>-</code></td>
<td>加速/减速</td>
</tr>
<tr>
<td><code>1</code> / <code>2</code></td>
<td>切换刷新模式</td>
</tr>
<tr>
<td><code>3</code>-<code>7</code></td>
<td>切换定时器模式</td>
</tr>
</tbody>
</table>
<h2 id="7">7. 编译与构建</h2>
<p>在 <code>console_player</code> 目录下运行 <code>make</code> 即可。</p>

<script>
    window.onscroll = function() {
        updateProgressBar();
    };

    document.getElementById("progress-container").onclick = function(event) {
        var rect = this.getBoundingClientRect();
        var clickX = event.clientX - rect.left;
        var percentage = clickX / this.offsetWidth;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        window.scrollTo(0, height * percentage);
    };

    function updateProgressBar() {
        var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        var scrolled = (winScroll / height) * 100;
        document.getElementById("progress-bar").style.width = scrolled + "%";
    }
</script>
</body>
</html>

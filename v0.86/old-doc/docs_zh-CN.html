<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YASP - Yet Another Sound Player</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            max-width: 800px;
            margin: 0 auto;
            padding: 30px;
            padding-bottom: 50px; /* Add padding to prevent content from being hidden by the progress bar */
        }
        #progress-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 8px;
            background-color: #f0f0f0;
            z-index: 1000;
            cursor: pointer;
        }
        #progress-bar {
            height: 100%;
            width: 0;
            background-color: #0366d6;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: .3em; }
        h3 { font-size: 1.25em; }
        h4 { font-size: 1em; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        code {
            padding: .2em .4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 3px;
        }
        pre code {
            display: inline;
            padding: 0;
            margin: 0;
            overflow: visible;
            line-height: inherit;
            word-wrap: normal;
            background-color: transparent;
            border: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin-top: 1em;
            margin-bottom: 1em;
        }
        th, td {
            border: 1px solid #dfe2e5;
            padding: 6px 13px;
        }
        th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        ul, ol { padding-left: 2em; }
        li { margin-top: .25em; }

        /* Hierarchical TOC styles */
        .toc-level-1 { font-weight: 500; }
        .toc-level-2 { margin-left: 1.5em; }
        .toc-level-3 { margin-left: 3em; }
        .toc-level-4 { margin-left: 4.5em; }
        .toc-level-1 > a { font-size: 1.1em; }
        .toc-level-2 > a { font-size: 1.0em; }
        .toc-level-3 > a { font-size: 0.95em; }
        .toc-level-4 > a { font-size: 0.9em; color: #333; }

        blockquote {
            margin-left: 0;
            padding-left: 1em;
            color: #6a737d;
            border-left: .25em solid #dfe2e5;
        }
    </style>
</head>
<body>
<div id="progress-container">
    <div id="progress-bar"></div>
</div>
<h1 id="yasp-yet-another-sound-player">YASP - Yet Another Sound Player</h1>
<h2 id="">摘要</h2>
<p>YASP (Yet Another Sound Player) 是一款专为 SPFM (Sound-Processing FM-synthesis) 系列硬件设计的命令行音乐播放器。它专注于高效、精确地播放经典的 VGM 和 S98 格式音乐文件，并通过多种可配置的刷新模式和计时器选项，为用户提供极致的复古音频体验。</p>
<hr>
<h2 id="table-of-contents">目录</h2>
<ol>
<li> <a href="#项目背景">项目背景</a></li>
<li> <a href="#功能特色">功能特色</a></li>
<li> <a href="#操作方法">操作方法</a></li>
<li> <a href="#编译方法">编译方法</a></li>
<li> <a href="#参考源码">参考源码</a></li>
</ol>
<hr>
<h2 id="">正文</h2>
<h3 id="">项目背景</h3>
<p>本项目旨在为 SPFM 硬件爱好者打造一款功能强大且高度可定制的命令行音乐播放器。项目的开发由以下成员合作完成：</p>
<ul>
<li>  <strong>Denjhang (项目所有者/主要开发者):</strong> 负责提出项目需求、核心架构设计、提供关键技术实现（如高精度定时器示例代码），并进行最终测试与验证。</li>
<li>  <strong>Cline (AI 软件工程师):</strong> 负责根据需求进行具体的代码实现、功能集成、错误修复、UI 调整以及文档撰写。</li>
</ul>
<h3 id="">功能特色</h3>
<ul>
<li>  <strong>广泛的芯片支持:</strong> 支持多种经典的 FM 合成芯片，包括 YM2608, YM2151, YM2612, YM2203, YM2413 等。</li>
<li>  <strong>多格式播放:</strong> 支持 <code>.vgm</code>, <code>.vgz</code>, 和 <code>.s98</code> 音乐文件格式。</li>
<li>  <strong>高级刷新模式:</strong></li>
<li>  <strong>刷新模式 (Flush Mode):</strong> 提供两种数据刷新模式，用于控制命令发送到 SPFM 硬件的频率。</li>
<li>  <strong>定时器模式 (Timer Mode):</strong> 为 VGM 播放提供多种高精度计时策略，以在不同系统负载下实现最精确的播放。</li>
<li>  <strong>内置文件浏览器:</strong></li>
<li>  按 <code>F</code> 键可打开文件浏览器，方便地在不同目录间切换和选择音乐文件。</li>
<li>  <strong>直观的播放界面:</strong></li>
<li>  清晰地展示当前播放的歌曲、总时长、芯片配置和各种模式状态。</li>
</ul>
<pre><code class="language- ```">    YASP - Yet Another Sound Player
    --------------------------------------------------
    Now Playing  : IF09_.vgm
    Total Time   : 01:28
    Slot 0: YM2608 | Slot 1: YM2151
    Flush Mode (1,2): Register-Level
    Timer Mode (3-0): VGMPlay-Optimized 1
    --------------------------------------------------
    [N] Next | [B] Prev | [P] Pause | [R] Random | [F] Browser | [+] Speed Up | [-] Speed Down | [Q] Quit
    --------------------------------------------------
    Status: Playing... | Random: Off | Speed: 1.00x
</code></pre>
<ul>
<li>  <strong>易于使用的文件浏览器:</strong></li>
<li>  提供分页和清晰的导航，让您轻松浏览音乐库。</li>
</ul>
<pre><code class="language- ```">    File Browser
    --------------------------------------------------
    Current Dir: ./console_player/music/if-vgm
    Now Playing: ./console_player/music/if-vgm/IF14_.vgm
    --------------------------------------------------
    -&gt; ../
       IF01_.vgm
       IF02_.vgm
       IF03_.vgm
       IF04_.vgm
       IF05_.vgm
       IF06_.vgm
       IF07_.vgm
       IF08_.vgm
       IF09_.vgm
    --------------------------------------------------
    Page 1/2 | [Up/Down] Navigate | [Left/Right] Page | [Enter] Select | [F] Exit
</code></pre>
<ul>
<li>  <strong>自动配置保存:</strong></li>
<li>  芯片选择、播放速度、刷新模式以及上次播放的文件路径等设置会自动保存到 <code>config.ini</code> 文件中，并在下次启动时自动加载。</li>
<li>  <strong>实时播放控制:</strong> 支持在播放过程中进行下一首、上一首、暂停/继续、随机播放和播放速度微调。</li>
<li>  <strong>跨平台设计:</strong> 主要为 Windows 设计，但代码结构也兼容类 POSIX 系统（如 Linux）。</li>
</ul>
<h3 id="">刷新模式详解</h3>
<p>刷新模式决定了 YASP 将命令发送到 SPFM 硬件的频率。</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>模式</th>
<th>工作原理</th>
<th>优缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1</code></td>
<td><strong>寄存器级 (Register-Level)</strong></td>
<td>命令被持续写入一个内部缓冲区 (<code>spfm_write_buf</code>)。只有当缓冲区满，或者遇到一个需要精确计时的等待命令时，<code>spfm_flush</code> 函数才会被调用，将整个缓冲区的数据一次性通过 USB 发送给硬件。</td>
<td><strong>优点:</strong> 吞吐量最大化。通过将多个命令合并为单次 USB 传输，极大地减少了驱动和硬件的开销，性能最高。<br><strong>缺点:</strong> 命令的发送不是实时的，可能会引入微小的延迟。</td>
</tr>
<tr>
<td><code>2</code></td>
<td><strong>命令级 (Command-Level)</strong></td>
<td><strong>(默认)</strong> 在处理完 VGM 文件中的<strong>每一个</strong>命令（如一次寄存器写入或一个短等待）后，都会立即调用 <code>spfm_flush</code> 函数。</td>
<td><strong>优点:</strong> 提供了最即时的响应，确保每个命令都以最小的延迟发送到硬件。<br><strong>缺点:</strong> USB 传输非常频繁，驱动开销较大，理论性能低于寄存器级模式。</td>
</tr>
</tbody>
</table>
<h3 id="vgm">定时器模式详解 (VGM 播放)</h3>
<p>YASP 为 VGM 播放提供了多种先进的定时器模式。这些模式的核心思想是<strong>不再信任</strong>操作系统提供的 <code>sleep</code> 函数，而是利用高精度性能计数器 (<code>QueryPerformanceCounter</code>) 来<strong>补偿</strong>或<strong>驱动</strong>播放循环。</p>
<p><em>注意：这些模式仅影响 <code>.vgm</code> 和 <code>.vgz</code> 文件的播放。<code>.s98</code> 文件使用其自身的、基于硬件的同步机制 (<code>0xFF</code> 命令)，不受这些模式影响。</em></p>
<h4 id="a-sleep-compensated-sleep">A. 补偿 Sleep 模式 (Compensated Sleep)</h4>
<p>这类模式的共同点是：在一个主循环中，首先根据真实流逝时间计算出“时间债务”（需要处理的样本数），然后处理样本来“偿还”债务，最后调用一个 <code>sleep</code> 函数来让出 CPU。即使 <code>sleep</code> 不精确，下一次循环也能自动补偿误差。</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>模式</th>
<th><code>g_timer_mode</code></th>
<th><code>sleep</code> 实现</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>3</code></td>
<td><strong>高精度补偿 (默认)</strong></td>
<td>0</td>
<td>使用 <code>CreateWaitableTimer</code> (高精度内核定时器) 来实现 <code>sleep</code>。</td>
<td><strong>通用推荐</strong>。CPU 占用低，精度高，是稳定性和性能的最佳平衡点。</td>
</tr>
<tr>
<td><code>4</code></td>
<td><strong>混合补偿</strong></td>
<td>1</td>
<td>使用 <code>Sleep()</code> 结合忙等待 (spin-wait) 的混合方式来实现 <code>sleep</code>。</td>
<td>作为备用选项。在某些系统上可能比模式 3 响应更快，但 CPU 占用稍高。</td>
</tr>
<tr>
<td><code>5</code></td>
<td><strong>多媒体补偿</strong></td>
<td>2</td>
<td>使用 <code>timeSetEvent</code> (多媒体定时器) 来实现 <code>sleep</code>。</td>
<td>作为备用选项。理论上精度很高，但定时器回调会带来一些额外开销。</td>
</tr>
</tbody>
</table>
<h4 id="b-event-driven">B. 事件驱动模式 (Event-Driven)</h4>
<p>这类模式不依赖于 <code>sleep</code>，而是由一个外部定时器来“唤醒”播放循环。</p>
<table>
<thead>
<tr>
<th>按键</th>
<th>模式</th>
<th><code>g_timer_mode</code></th>
<th>工作原理</th>
<th>推荐场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>6</code></td>
<td><strong>经典 VGMPlay</strong></td>
<td>3</td>
<td><strong>(高度推荐)</strong> 由一个 1ms 的高精度多媒体定时器 (<code>timeSetEvent</code>) 唤醒主循环。每次唤醒后，根据真实流逝时间处理相应数量的样本。由于其步调由外部定时器控制，理论上比补偿模式更精确。</td>
<td>在大多数情况下非常稳定，是精确播放的黄金标准。</td>
</tr>
<tr>
<td><code>7</code></td>
<td><strong>优化 VGMPlay</strong></td>
<td>7</td>
<td><strong>(最稳定)</strong> 这是模式 6 的<strong>“防失控”</strong>版本。它在经典 VGMPlay 模式的基础上，增加了一个“最大帧样本数”的限制（相当于 1/60 秒的样本量），防止在系统瞬间卡顿后，声音突然“快进”或爆音。</td>
<td><strong>最高负载场景推荐</strong>。当您在后台运行高 CPU 任务时，此模式能提供最平滑的播放体验。</td>
</tr>
</tbody>
</table>
<h3 id="spfm">SPFM 通信协议详解</h3>
<p>YASP 通过 FTDI D2XX 驱动与 SPFM 硬件进行通信。协议的核心是高效地将寄存器写入和等待命令发送到设备。</p>
<h4 id="">设备识别与握手</h4>
<p>在初始化时，YASP 会尝试识别 SPFM 设备的类型。</p>
<ol>
<li> <strong>握手信号</strong>: 程序向设备发送 <code>0xFF</code> 字节。</li>
<li> <strong>设备响应</strong>:</li>
</ol>
<ul>
<li>  <strong>SPFM Light</strong> 设备会返回 "LT" 字符串。</li>
<li>  <strong>SPFM 标准版</strong> 设备会返回 "OK" 字符串。</li>
</ul>
<ol>
<li> <strong>兼容性模式</strong>: 根据代码中的注释，当前版本的 YASP <strong>绕过</strong>了此握手流程，并默认将设备识别为 <code>SPFM_TYPE_SPFM_LIGHT</code>。这是为了解决在某些特定硬件上，严格的握手流程可能导致识别失败的问题，从而提高了设备的兼容性。</li>
</ol>
<h4 id="">命令格式</h4>
<p>根据设备类型的不同，命令格式也不同：</p>
<ul>
<li>  <strong>SPFM Light (4 字节):</strong></li>
<li>  <code>{ slot, (port << 1), addr, data }</code></li>
<li>  <code>slot</code>: 芯片所在的插槽 (0 或 1)。</li>
<li>  <code>port</code>: 芯片的端口。</li>
<li>  <code>addr</code>: 要写入的寄存器地址。</li>
<li>  <code>data</code>: 要写入的数据。</li>
</ul>
<ul>
<li>  <strong>SPFM 标准版 (3 字节):</strong></li>
</ul>
<ul>
<li>  <code>{ (slot << 4) | port, addr, data }</code></li>
<li>  <code>slot</code>: 芯片所在的插槽 (0-7)。</li>
<li>  <code>port</code>: 芯片的端口 (0-3)。</li>
<li>  <code>addr</code>: 要写入的寄存器地址。</li>
<li>  <code>data</code>: 要写入的数据。</li>
</ul>
<p><em>注意：当前版本的 YASP 为了兼容性，默认使用 SPFM Light 模式。</em></p>
<h4 id="">写入缓冲机制</h4>
<p>为了最大化吞吐量并减少 FTDI 驱动的调用开销，YASP 实现了一个写入缓冲区 (<code>spfm_write_buf</code>)。</p>
<ol>
<li> 当调用 <code>spfm_write_reg</code> 等函数时，命令数据并<strong>不会</strong>立即发送，而是被暂存到这个缓冲区中。</li>
<li> 只有当缓冲区满，或者需要执行一个精确的等待操作时，<code>spfm_flush</code> 函数才会被调用。</li>
<li> <code>spfm_flush</code> 会将整个缓冲区的数据通过一次 <code>FT_Write</code> 调用发送给 SPFM 设备，从而大大提高了效率。</li>
</ol>
<h4 id="">硬件等待与软件等待</h4>
<p>YASP 采用了一种混合等待策略，以在精度和 CPU 占用之间取得平衡：</p>
<ul>
<li>  <strong>硬件等待 (Hardware Wait):</strong></li>
<li>  当设备为 <code>SPFM_Light</code> 且等待时间极短（小于 10 个音频样本）时，YASP 会发送 <code>0x80</code> 命令。</li>
<li>  这个命令由 SPFM 硬件本身来处理，可以实现非常精确的、几乎不占用 CPU 资源的短时间等待。</li>
<li>  <strong>软件等待 (Software Wait):</strong></li>
<li>  对于较长的等待，或者在不支持硬件等待的设备上，YASP 会调用 <code>yasp_usleep</code> 函数。</li>
<li>  该函数会根据用户选择的定时器模式（如高精度 Sleep、多媒体定时器等）来执行一个高精度的软件等待。</li>
</ul>
<p>这种设计使得 YASP 在处理 VGM/S98 文件中大量的短等待命令时非常高效，同时在需要长时间等待时又能让出 CPU，避免资源浪费。</p>
<h3 id="">操作方法</h3>
<h4 id="">播放器界面</h4>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>q</code></td>
<td>退出播放器</td>
</tr>
<tr>
<td><code>p</code></td>
<td>暂停/继续播放</td>
</tr>
<tr>
<td><code>n</code></td>
<td>下一首</td>
</tr>
<tr>
<td><code>b</code></td>
<td>上一首</td>
</tr>
<tr>
<td><code>r</code></td>
<td>开启/关闭随机播放</td>
</tr>
<tr>
<td><code>f</code></td>
<td>打开文件浏览器</td>
</tr>
<tr>
<td><code>+</code></td>
<td>加快播放速度 (步进 0.01)</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减慢播放速度 (步进 0.01)</td>
</tr>
<tr>
<td><code>1</code></td>
<td>切换到 <code>Register-Level</code> 刷新模式</td>
</tr>
<tr>
<td><code>2</code></td>
<td>切换到 <code>Command-Level</code> 刷新模式 (默认)</td>
</tr>
<tr>
<td><code>3</code>-<code>7</code></td>
<td>切换不同的 VGM 计时器模式 (详见上一节)</td>
</tr>
</tbody>
</table>
<h4 id="">文件浏览器界面</h4>
<table>
<thead>
<tr>
<th>按键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>↑</code> / <code>↓</code></td>
<td>上/下移动光标</td>
</tr>
<tr>
<td><code>←</code> / <code>→</code></td>
<td>上/下翻页</td>
</tr>
<tr>
<td><code>Enter</code></td>
<td>进入目录或选择要播放的文件</td>
</tr>
<tr>
<td><code>Backspace</code></td>
<td>返回上一级目录</td>
</tr>
<tr>
<td><code>f</code></td>
<td>退出文件浏览器，返回播放器界面</td>
</tr>
</tbody>
</table>
<h3 id="">编译方法</h3>
<h4 id="windows-mingw-msys2">Windows (使用 MinGW/MSYS2)</h4>
<ol>
<li> 确保您已安装 MinGW-w64 或 MSYS2，并已将其 <code>bin</code> 目录添加到系统 PATH。</li>
<li> 将 FTDI D2XX 驱动文件 (<code>ftd2xx.h</code>, <code>ftd2xx.lib</code> 或 <code>libftd2xx.a</code>) 放置在项目根目录下的 <code>ftdi_driver</code> 文件夹中。</li>
<li> 打开命令行，导航到 <code>console_player</code> 目录。</li>
<li> 运行 <code>make</code> 命令进行编译：</li>
</ol>
<pre><code class="language- ```bash">    make -C console_player
</code></pre>
<ol>
<li> 编译成功后，将在 <code>console_player</code> 目录下生成 <code>yasp_test.exe</code>。</li>
</ol>
<h4 id="linux-macos">Linux / macOS</h4>
<p>编译方法与 Windows 类似，但需要确保已安装 <code>libftdi</code> 开发库。<code>makefile</code> 会自动处理平台特定的链接选项。</p>
<h3 id="">参考源码</h3>
<p>本 C 语言版本的播放器在开发过程中，深度参考了以下项目：</p>
<ul>
<li>  <strong><code>node-spfm</code></strong> (由 Denjhang 开发):</li>
<li>  <strong>位置</strong>: <code>D:\working\vscode-projects\yasp11\node-spfm-denjhang-main</code></li>
<li>  <strong>贡献</strong>: 这是一个功能完备的 Node.js 实现，为本项目的 C 语言移植提供了核心逻辑和算法基础，尤其是在 SPFM 通信协议、VGM/S98 文件解析和芯片控制逻辑方面。</li>
</ul>
<ul>
<li>  <strong>VGMPlay</strong> (由 Valley Bell 开发):</li>
<li>  <strong>贡献</strong>: 在项目早期，传统的 <code>sleep</code>-based 计时方式在进行窗口切换、文件解压缩等高 CPU 负载操作时，会导致播放速度明显变慢、不稳定。为了解决此问题，项目引入并实现了 VGMPlay 的核心计时模型。该模型不依赖于固定的 <code>sleep</code>，而是根据真实流逝的时间 (<code>QueryPerformanceCounter</code>) 来动态计算需要处理的音频样本数量，从根本上保证了在各种系统负载下播放的稳定性和精确性。</li>
</ul>
<h4 id="">主要参考部分:</h4>
<ul>
<li>  <strong>SPFM 通信协议:</strong></li>
</ul>
<p>    <code>node-spfm/src/spfm.ts</code> 中定义的与 SPFM 硬件握手、发送命令和数据的逻辑，是本 C 项目中 <code>console_player/spfm.c</code> 实现的基础。包括设备初始化、芯片复位和寄存器写入等关键操作。</p>
<ul>
<li>  <strong>VGM 文件解析:</strong></li>
</ul>
<p>    <code>node-spfm/src/vgm.ts</code> 中的 VGM 文件头解析、数据块处理和命令解析逻辑，被直接借鉴并用 C 语言在 <code>console_player/vgm.c</code> 中重新实现。这确保了对 VGM 格式的精确支持。</p>
<ul>
<li>  <strong>芯片控制逻辑:</strong></li>
</ul>
<p>    <code>node-spfm/src/chips/</code> 目录下针对不同 FM 芯片（如 YM2151, YM2608）的控制类，为本项目的 <code>console_player/ym2151.c</code>, <code>console_player/ym2608.c</code> 等文件提供了寄存器地址和控制指令的准确参考。</p>
<p>除了 <code>node-spfm</code>，本项目还涉及以下文件的修改与实现：</p>
<ul>
<li>  <code>console_player/main.c</code>: 主程序入口，负责初始化、配置加载、播放循环和键盘输入处理。</li>
<li>  <code>console_player/play.c</code>: 播放器 UI 显示和文件播放逻辑的核心。</li>
<li>  <code>console_player/util.c</code> & <code>console_player/util.h</code>: 实现了各种计时器模式和辅助工具函数。</li>
<li>  <code>console_player/makefile</code>: 项目的构建脚本，负责编译和链接所有源文件。</li>
</ul>

<script>
    window.onscroll = function() {
        updateProgressBar();
    };

    document.getElementById("progress-container").onclick = function(event) {
        var rect = this.getBoundingClientRect();
        var clickX = event.clientX - rect.left;
        var percentage = clickX / this.offsetWidth;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        window.scrollTo(0, height * percentage);
    };

    function updateProgressBar() {
        var winScroll = document.body.scrollTop || document.documentElement.scrollTop;
        var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
        var scrolled = (winScroll / height) * 100;
        document.getElementById("progress-bar").style.width = scrolled + "%";
    }
</script>
</body>
</html>

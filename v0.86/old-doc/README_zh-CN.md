# YASP - Yet Another Sound Player

## 摘要

YASP (Yet Another Sound Player) 是一款专为 SPFM (Sound-Processing FM-synthesis) 系列硬件设计的命令行音乐播放器。它专注于高效、精确地播放经典的 VGM 和 S98 格式音乐文件，并通过多种可配置的刷新模式和计时器选项，为用户提供极致的复古音频体验。

---

## 目录

1.  [项目背景](#项目背景)
2.  [功能特色](#功能特色)
3.  [操作方法](#操作方法)
4.  [编译方法](#编译方法)
5.  [参考源码](#参考源码)

---

## 正文

### 项目背景

本项目旨在为 SPFM 硬件爱好者打造一款功能强大且高度可定制的命令行音乐播放器。项目的开发由以下成员合作完成：

*   **Denjhang (项目所有者/主要开发者):** 负责提出项目需求、核心架构设计、提供关键技术实现（如高精度定时器示例代码），并进行最终测试与验证。
*   **Cline (AI 软件工程师):** 负责根据需求进行具体的代码实现、功能集成、错误修复、UI 调整以及文档撰写。

### 功能特色

*   **广泛的芯片支持:** 支持多种经典的 FM 合成芯片，包括 YM2608, YM2151, YM2612, YM2203, YM2413 等。
*   **多格式播放:** 支持 `.vgm`, `.vgz`, 和 `.s98` 音乐文件格式。
*   **高级刷新模式:**
    *   **刷新模式 (Flush Mode):** 提供两种数据刷新模式，用于控制命令发送到 SPFM 硬件的频率。
    *   **定时器模式 (Timer Mode):** 为 VGM 播放提供多种高精度计时策略，以在不同系统负载下实现最精确的播放。
*   **内置文件浏览器:**
    *   按 `F` 键可打开文件浏览器，方便地在不同目录间切换和选择音乐文件。
*   **直观的播放界面:**
    *   清晰地展示当前播放的歌曲、总时长、芯片配置和各种模式状态。
    ```
    YASP - Yet Another Sound Player
    --------------------------------------------------
    Now Playing  : IF09_.vgm
    Total Time   : 01:28
    Slot 0: YM2608 | Slot 1: YM2151
    Flush Mode (1,2): Register-Level
    Timer Mode (3-0): VGMPlay-Optimized 1
    --------------------------------------------------
    [N] Next | [B] Prev | [P] Pause | [R] Random | [F] Browser | [+] Speed Up | [-] Speed Down | [Q] Quit
    --------------------------------------------------
    Status: Playing... | Random: Off | Speed: 1.00x
    ```
*   **易于使用的文件浏览器:**
    *   提供分页和清晰的导航，让您轻松浏览音乐库。
    ```
    File Browser
    --------------------------------------------------
    Current Dir: ./console_player/music/if-vgm
    Now Playing: ./console_player/music/if-vgm/IF14_.vgm
    --------------------------------------------------
    -> ../
       IF01_.vgm
       IF02_.vgm
       IF03_.vgm
       IF04_.vgm
       IF05_.vgm
       IF06_.vgm
       IF07_.vgm
       IF08_.vgm
       IF09_.vgm
    --------------------------------------------------
    Page 1/2 | [Up/Down] Navigate | [Left/Right] Page | [Enter] Select | [F] Exit
    ```
*   **自动配置保存:**
    *   芯片选择、播放速度、刷新模式以及上次播放的文件路径等设置会自动保存到 `config.ini` 文件中，并在下次启动时自动加载。
*   **实时播放控制:** 支持在播放过程中进行下一首、上一首、暂停/继续、随机播放和播放速度微调。
*   **跨平台设计:** 主要为 Windows 设计，但代码结构也兼容类 POSIX 系统（如 Linux）。

### 刷新模式详解

刷新模式决定了 YASP 将命令发送到 SPFM 硬件的频率。

| 按键 | 模式 | 工作原理 | 优缺点 |
| :--: | :-- | :-- | :-- |
| `1` | **寄存器级 (Register-Level)** | 命令被持续写入一个内部缓冲区 (`spfm_write_buf`)。只有当缓冲区满，或者遇到一个需要精确计时的等待命令时，`spfm_flush` 函数才会被调用，将整个缓冲区的数据一次性通过 USB 发送给硬件。 | **优点:** 吞吐量最大化。通过将多个命令合并为单次 USB 传输，极大地减少了驱动和硬件的开销，性能最高。<br>**缺点:** 命令的发送不是实时的，可能会引入微小的延迟。 |
| `2` | **命令级 (Command-Level)** | **(默认)** 在处理完 VGM 文件中的**每一个**命令（如一次寄存器写入或一个短等待）后，都会立即调用 `spfm_flush` 函数。 | **优点:** 提供了最即时的响应，确保每个命令都以最小的延迟发送到硬件。<br>**缺点:** USB 传输非常频繁，驱动开销较大，理论性能低于寄存器级模式。 |

### 定时器模式详解 (VGM 播放)

YASP 为 VGM 播放提供了多种先进的定时器模式。这些模式的核心思想是**不再信任**操作系统提供的 `sleep` 函数，而是利用高精度性能计数器 (`QueryPerformanceCounter`) 来**补偿**或**驱动**播放循环。

*注意：这些模式仅影响 `.vgm` 和 `.vgz` 文件的播放。`.s98` 文件使用其自身的、基于硬件的同步机制 (`0xFF` 命令)，不受这些模式影响。*

#### A. 补偿 Sleep 模式 (Compensated Sleep)
这类模式的共同点是：在一个主循环中，首先根据真实流逝时间计算出“时间债务”（需要处理的样本数），然后处理样本来“偿还”债务，最后调用一个 `sleep` 函数来让出 CPU。即使 `sleep` 不精确，下一次循环也能自动补偿误差。

| 按键 | 模式 | `g_timer_mode` | `sleep` 实现 | 推荐场景 |
| :--: | :-- | :---: | :-- | :-- |
| `3` | **高精度补偿 (默认)** | 0 | 使用 `CreateWaitableTimer` (高精度内核定时器) 来实现 `sleep`。 | **通用推荐**。CPU 占用低，精度高，是稳定性和性能的最佳平衡点。 |
| `4` | **混合补偿** | 1 | 使用 `Sleep()` 结合忙等待 (spin-wait) 的混合方式来实现 `sleep`。 | 作为备用选项。在某些系统上可能比模式 3 响应更快，但 CPU 占用稍高。 |
| `5` | **多媒体补偿** | 2 | 使用 `timeSetEvent` (多媒体定时器) 来实现 `sleep`。 | 作为备用选项。理论上精度很高，但定时器回调会带来一些额外开销。 |

#### B. 事件驱动模式 (Event-Driven)
这类模式不依赖于 `sleep`，而是由一个外部定时器来“唤醒”播放循环。

| 按键 | 模式 | `g_timer_mode` | 工作原理 | 推荐场景 |
| :--: | :-- | :---: | :-- | :-- |
| `6` | **经典 VGMPlay** | 3 | **(高度推荐)** 由一个 1ms 的高精度多媒体定时器 (`timeSetEvent`) 唤醒主循环。每次唤醒后，根据真实流逝时间处理相应数量的样本。由于其步调由外部定时器控制，理论上比补偿模式更精确。 | 在大多数情况下非常稳定，是精确播放的黄金标准。 |
| `7` | **优化 VGMPlay** | 7 | **(最稳定)** 这是模式 6 的**“防失控”**版本。它在经典 VGMPlay 模式的基础上，增加了一个“最大帧样本数”的限制（相当于 1/60 秒的样本量），防止在系统瞬间卡顿后，声音突然“快进”或爆音。 | **最高负载场景推荐**。当您在后台运行高 CPU 任务时，此模式能提供最平滑的播放体验。 |

### SPFM 通信协议详解

YASP 通过 FTDI D2XX 驱动与 SPFM 硬件进行通信。协议的核心是高效地将寄存器写入和等待命令发送到设备。

#### 设备识别与握手

在初始化时，YASP 会尝试识别 SPFM 设备的类型。

1.  **握手信号**: 程序向设备发送 `0xFF` 字节。
2.  **设备响应**:
    *   **SPFM Light** 设备会返回 "LT" 字符串。
    *   **SPFM 标准版** 设备会返回 "OK" 字符串。
3.  **兼容性模式**: 根据代码中的注释，当前版本的 YASP **绕过**了此握手流程，并默认将设备识别为 `SPFM_TYPE_SPFM_LIGHT`。这是为了解决在某些特定硬件上，严格的握手流程可能导致识别失败的问题，从而提高了设备的兼容性。

#### 命令格式

根据设备类型的不同，命令格式也不同：

*   **SPFM Light (4 字节):**
    *   `{ slot, (port << 1), addr, data }`
    *   `slot`: 芯片所在的插槽 (0 或 1)。
    *   `port`: 芯片的端口。
    *   `addr`: 要写入的寄存器地址。
    *   `data`: 要写入的数据。

*   **SPFM 标准版 (3 字节):**
    *   `{ (slot << 4) | port, addr, data }`
    *   `slot`: 芯片所在的插槽 (0-7)。
    *   `port`: 芯片的端口 (0-3)。
    *   `addr`: 要写入的寄存器地址。
    *   `data`: 要写入的数据。

*注意：当前版本的 YASP 为了兼容性，默认使用 SPFM Light 模式。*

#### 写入缓冲机制

为了最大化吞吐量并减少 FTDI 驱动的调用开销，YASP 实现了一个写入缓冲区 (`spfm_write_buf`)。

1.  当调用 `spfm_write_reg` 等函数时，命令数据并**不会**立即发送，而是被暂存到这个缓冲区中。
2.  只有当缓冲区满，或者需要执行一个精确的等待操作时，`spfm_flush` 函数才会被调用。
3.  `spfm_flush` 会将整个缓冲区的数据通过一次 `FT_Write` 调用发送给 SPFM 设备，从而大大提高了效率。

#### 硬件等待与软件等待

YASP 采用了一种混合等待策略，以在精度和 CPU 占用之间取得平衡：

*   **硬件等待 (Hardware Wait):**
    *   当设备为 `SPFM_Light` 且等待时间极短（小于 10 个音频样本）时，YASP 会发送 `0x80` 命令。
    *   这个命令由 SPFM 硬件本身来处理，可以实现非常精确的、几乎不占用 CPU 资源的短时间等待。
*   **软件等待 (Software Wait):**
    *   对于较长的等待，或者在不支持硬件等待的设备上，YASP 会调用 `yasp_usleep` 函数。
    *   该函数会根据用户选择的定时器模式（如高精度 Sleep、多媒体定时器等）来执行一个高精度的软件等待。

这种设计使得 YASP 在处理 VGM/S98 文件中大量的短等待命令时非常高效，同时在需要长时间等待时又能让出 CPU，避免资源浪费。

### 操作方法

#### 播放器界面

| 按键 | 功能 |
| :--: | :-- |
| `q` | 退出播放器 |
| `p` | 暂停/继续播放 |
| `n` | 下一首 |
| `b` | 上一首 |
| `r` | 开启/关闭随机播放 |
| `f` | 打开文件浏览器 |
| `+` | 加快播放速度 (步进 0.01) |
| `-` | 减慢播放速度 (步进 0.01) |
| `1` | 切换到 `Register-Level` 刷新模式 |
| `2` | 切换到 `Command-Level` 刷新模式 (默认) |
| `3`-`7` | 切换不同的 VGM 计时器模式 (详见上一节) |

#### 文件浏览器界面

| 按键 | 功能 |
| :--: | :-- |
| `↑` / `↓` | 上/下移动光标 |
| `←` / `→` | 上/下翻页 |
| `Enter` | 进入目录或选择要播放的文件 |
| `Backspace` | 返回上一级目录 |
| `f` | 退出文件浏览器，返回播放器界面 |

### 编译方法

#### Windows (使用 MinGW/MSYS2)

1.  确保您已安装 MinGW-w64 或 MSYS2，并已将其 `bin` 目录添加到系统 PATH。
2.  将 FTDI D2XX 驱动文件 (`ftd2xx.h`, `ftd2xx.lib` 或 `libftd2xx.a`) 放置在项目根目录下的 `ftdi_driver` 文件夹中。
3.  打开命令行，导航到 `console_player` 目录。
4.  运行 `make` 命令进行编译：
    ```bash
    make -C console_player
    ```
5.  编译成功后，将在 `console_player` 目录下生成 `yasp_test.exe`。

#### Linux / macOS

编译方法与 Windows 类似，但需要确保已安装 `libftdi` 开发库。`makefile` 会自动处理平台特定的链接选项。

### 参考源码

本 C 语言版本的播放器在开发过程中，深度参考了以下项目：

*   **`node-spfm`** (由 Denjhang 开发):
    *   **位置**: `D:\working\vscode-projects\yasp11\node-spfm-denjhang-main`
    *   **贡献**: 这是一个功能完备的 Node.js 实现，为本项目的 C 语言移植提供了核心逻辑和算法基础，尤其是在 SPFM 通信协议、VGM/S98 文件解析和芯片控制逻辑方面。

*   **VGMPlay** (由 Valley Bell 开发):
    *   **贡献**: 在项目早期，传统的 `sleep`-based 计时方式在进行窗口切换、文件解压缩等高 CPU 负载操作时，会导致播放速度明显变慢、不稳定。为了解决此问题，项目引入并实现了 VGMPlay 的核心计时模型。该模型不依赖于固定的 `sleep`，而是根据真实流逝的时间 (`QueryPerformanceCounter`) 来动态计算需要处理的音频样本数量，从根本上保证了在各种系统负载下播放的稳定性和精确性。

#### 主要参考部分:

*   **SPFM 通信协议:**
    `node-spfm/src/spfm.ts` 中定义的与 SPFM 硬件握手、发送命令和数据的逻辑，是本 C 项目中 `console_player/spfm.c` 实现的基础。包括设备初始化、芯片复位和寄存器写入等关键操作。
*   **VGM 文件解析:**
    `node-spfm/src/vgm.ts` 中的 VGM 文件头解析、数据块处理和命令解析逻辑，被直接借鉴并用 C 语言在 `console_player/vgm.c` 中重新实现。这确保了对 VGM 格式的精确支持。
*   **芯片控制逻辑:**
    `node-spfm/src/chips/` 目录下针对不同 FM 芯片（如 YM2151, YM2608）的控制类，为本项目的 `console_player/ym2151.c`, `console_player/ym2608.c` 等文件提供了寄存器地址和控制指令的准确参考。

除了 `node-spfm`，本项目还涉及以下文件的修改与实现：

*   `console_player/main.c`: 主程序入口，负责初始化、配置加载、播放循环和键盘输入处理。
*   `console_player/play.c`: 播放器 UI 显示和文件播放逻辑的核心。
*   `console_player/util.c` & `console_player/util.h`: 实现了各种计时器模式和辅助工具函数。
*   `console_player/makefile`: 项目的构建脚本，负责编译和链接所有源文件。

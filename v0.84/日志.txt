禁止在bash中使用&或者&&，最好单步执行命令，请牢记。

上次使用的是make -C console_player clean
make -C console_player
./console_player/yasp_test.exe

console_player继续专注于ym2151播放效率，保持现有刷新模式的同时，
为按键3/4/5/6/7/8/9分配不同的定时器api组成的刷新模式，
请添加Hybrid Sleep (10us)模式，
timeBeginPeriod(1) + timeSetEvent多媒体定时器模式，
MMCSS + IAudioClient3模式。注意不要修改spfm握手部分源码。
禁止在bash中使用&或者&&，最好单步执行命令，请牢记。

播放器界面要显示：当前芯片型号和当前刷新模式

console_player继续专注于ym2151播放效率，保持现有刷新模式的同时，为按键3/4/5/6/7/8/9分配不同的定时器api组成的刷新模式，注意不要修改spfm握手部分源码。禁止在bash中使用&或者&&，最好单步执行命令，请牢记。

timeBeginPeriod(1) + timeSetEvent
MMCSS + IAudioClient3

Command-Level占用高，缩小窗口导致播放速度变慢，过几秒恢复
Register-Level占用高，打字拖慢速度。

Precise Wait (1us)高，窗口拖慢
Spin Wait (1us)中，窗口拖慢
Hybrid Sleep (10us)稳定中等，缩小窗口拖慢，恢复时间更快

Precise Wait (10us)稳定在10-12，窗口拖慢，缓慢恢复

Spin Wait (10us)偏高，窗口拖慢，缓慢恢复
Spin Wait (50us)很高，窗口拖慢，缓慢恢复，删除该模式

console_player继续专注于ym2151播放时序和稳定性，参考node-spfm-denjhang-main实现自己的方法，保守修改现有源码，注意不要修改spfm握手部分源码。禁止在bash中使用&或者&&，最好单步执行命令，请牢记。

很好，从现在开始对ym2151播放时序进行微调，在播放界面使用数字键1/2/3/4切换微调时序，你写4个微调方法，然后我进行测试，看哪一个微调方法会更接近。注意切换曲目不改变微调方法。
我已根据您的要求，成功为您构建了一个 YM2151 时序的交互式微调测试平台。
----------------------------------------------------------------------------------
现在，您可以在播放过程中，通过键盘实时切换不同的时序策略，以找到最适合您硬件的“最佳点”。

__功能实现如下__：

- __四种微调模式__：

  - __模式1 (按键`1`)__: 在每次写入 YM2151 寄存&#x5668;__&#x524D;__，加入一个微秒级的自旋等待。
  - __模式2 (按键`2`)__: 在每次写&#x5165;__&#x540E;__，加入一个微秒级的自旋等待。
  - __模式3 (按键`3`)__: 在每次写入后，__强制刷新__ SPFM 的缓冲区，确保命令立即发送。
  - __模式4 (按键`4`)__: 在每次写入&#x7684;__&#x524D;后__，都加入一个微秒级的自旋等待。
  - __默认模式 (按键`0`)__: 恢复为默认的写入行为，无任何额外延迟或操作。

- __实时切换__：在播放界面，您可以随时按下数字键 `0`, `1`, `2`, `3`, `4` 来切换模式。屏幕上会显示当前激活的模式名称。

- __状态保持__：您选择的微调模式在切换歌曲时会保持不变，方便您在不同乐曲下进行一致性测试。

所有必要的代码修改（在 `main.c`, `ym2151.c`, `util.c` 及其头文件中）都已完成并成功编译。请运行最终版本，开始您的时序微调测试。
-------------------------------------------------------
我已根据您的要求，将两种不同的刷新策略集成为一个可实时切换的功能。

现在，您可以在播放过程中通过按键来选择最适合当前需求的刷新模式：

- __按 `1` 键：切换到“寄存器级刷新”模式。__

  - __工作方式__：每次向 YM2151 写入寄存器后，都会立即强制刷新缓冲区。
  - __优点__：提供最极致的时序精度，是解决时序问题的最可靠方案。
  - __缺点__：USB通信非常频繁，效率较低。

- __按 `2` 键：切换到“VGM命令级刷新”模式（默认）。__

  - __工作方式__：只有在处理完一个完整的VGM命令（如寄存器写入、等待等）后，才会刷新缓冲区。
  - __优点__：在保证时序边界清晰的同时，通过批量发送命令，显著提高了效率。
  - __缺点__：对于极少数需要寄存器间微秒级精确时序的特殊乐曲，可能不如模式1精确。

这个新功能为您提供了在“极致精度”和“高效性能”之间自由选择的权力。代码已成功编译，您可以立即体验这个最终版本。
